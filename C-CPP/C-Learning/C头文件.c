// 所有学习过C语言的朋友都熟悉这样一段代码：

// #include <stdio.h>
//  int main(int argc, char *argv[])                                                                   
// {

//     return 0;
// }

// 那么，你真的了解 <stdio.h> 吗？ <stdio.h> 到底是什么呢？ <stdio.h> 和 "stdio.h" 这两种写法皆可行吗？为什么？这二者有何区别呢？
// 如果让你自己写一个类似头文件 <stdio.h> 的头文件，你能写出来并在大型项目中四处引用属于自己的头文件吗？

// 这篇文章像大家详细介绍 C语言中的 头文件： 
// 头文件是一个包含函数声明、宏定义、数据类型定义和全局变量声明的文件，通常配合 .c 源文件使用。
// 头文件通过 #include 指令被引入到源文件中（或其他头文件中）。

// 头文件的作用：
// 代码复用：将通用的函数、宏、类型等内容放入头文件，可以在多个源文件中共享，避免重复编写。
// 声明与定义分离：头文件中通常只包含声明，而具体的实现代码（定义）放在 .c 文件中，从而实现模块化设计。
// 方便管理：将代码逻辑拆分到不同的头文件和源文件中，可以让项目结构更加清晰，方便维护和扩展。
// 提高代码可读性：头文件可以让程序员快速了解模块的接口和功能，而无需深入查看源文件的具体实现。
// 头文件的内容
// 头文件通常包含以下内容：

// 1.函数声明：在头文件中声明函数的原型，使其他源文件可以调用这些函数。

// // math_utils.h
// #ifndef __MATH_UTILS_H
// #define __MATH_UTILS_H

// // 函数声明
// int add(int a, int b);
// int multiply(int a, int b);

// #endif

// 2.宏定义：可以在头文件中定义一些宏，用于常量表达式、条件编译或代码优化。

// #define PI 3.14159
// #define MAX(a, b) ((a) > (b) ? (a) : (b))

// 3.数据类型定义：头文件中可以使用 typedef 定义新的数据类型，也可以定义结构体或枚举。

// // 定义新类型
// typedef unsigned int uint;

// // 定义结构体
// typedef struct {
//     int x;
//     int y;
// } Point;

// // 定义枚举
// typedef enum {
//     RED,
//     GREEN,
//     BLUE
// } Color;

// 4.全局变量声明：在头文件中声明全局变量，但其定义应放在对应的 .c 文件中。

// // 头文件中声明全局变量
// extern int global_variable;

// // 源文件中定义全局变量
// int global_variable = 42;

// 5.内联函数（C99 及以上版本）：头文件可以包含内联函数的定义，这种函数通常体积小、性能高，直接在调用处展开。

// static inline int square(int x) {
//     return x * x;
// }

// 创建和使用头文件
// 1.创建头文件
// 创建一个 扩展名为 .h 的文件（如 math_utils.h）。
// 将函数声明、宏定义、数据类型定义等内容写入其中。

// 示例头文件：math_utils.h

// #ifndef MATH_UTILS_H  // 防止重复包含
// #define MATH_UTILS_H

// // 函数声明
// int add(int a, int b);
// int multiply(int a, int b);

// // 宏定义
// #define PI 3.14159

// #endif

// 2.引入头文件
// 在需要使用头文件内容的源文件中，通过 #include 指令引入头文件。

// #include "math_utils.h"  // 自定义头文件
// #include <stdio.h>       // 标准头文件

// int main() {
//     int result = add(3, 5);
//     printf("3 + 5 = %d\n", result);
//     return 0;
// }

// 3.定义对应的实现文件
// 头文件提供的是声明，而具体的实现需要在对应的 .c 文件中定义

// #include "math_utils.h"

// int add(int a, int b) {
//     return a + b;
// }

// int multiply(int a, int b) {
//     return a * b;
// }

// 4.编译与链接
// 编译时，需要将头文件的 .c 文件与主程序一起编译并链接：

// gcc main.c math_utils.c -o program

// 标准头文件
// C 标准库提供了一系列常用的头文件，包含许多函数和宏，方便程序开发。以下是一些常见的标准头文件：

// 头文件	                描述
// <stdio.h>	标准输入输出（如 printf、scanf）
// <stdlib.h>	通用工具（如内存分配、随机数生成）
// <string.h>	字符串操作（如 strcpy、strlen）
// <math.h>	数学函数（如 sin、sqrt）
// <time.h>	时间和日期操作
// <ctype.h>	字符处理（如 isalpha、isdigit）
// <limits.h>	各种数据类型的限制
// <float.h>	浮点数特性
// <assert.h>	断言
// <stddef.h>	定义标准类型（如 size_t、NULL）
// <stdint.h>	定义精确宽度的整数类型（如 int32_t）
// <errno.h>	错误代码

// 示例：使用 <math.h> 中的函数

// #include <stdio.h>
// #include <math.h>

// int main() {
//     double result = sqrt(16.0);  // 平方根
//     printf("Square root of 16 = %.2f\n", result);
//     return 0;
// }

// 防止头文件重复包含
// 在大型项目中，头文件可能会被多次包含，导致重复定义错误。为避免这种问题，头文件通常使用头文件保护机制：

// 1.宏保护
// 通过条件编译指令 #ifndef 和 #define 实现头文件保护。

// #ifndef HEADER_FILE_NAME_H
// #define HEADER_FILE_NAME_H

// // 头文件内容

// #endif

// 2.#pragma once（非标准但常用）
// 使用 #pragma once 指令也是一种防止重复包含的方式，且更简洁。

// #pragma once

// // 头文件内容

// 头文件的常见问题
// 重复包含问题
// 当头文件没有使用保护机制时，可能会导致重复定义错误。
// 解决方法： ① 使用 #ifndef 和 #define 宏保护。② 或者使用 #pragma once。

// 头文件与实现文件不匹配
// 如果头文件中声明的函数没有在实现文件中定义，或者函数签名不一致，可能会导致编译错误或运行时错误。
// 解决方法： ① 保证头文件中的声明与 .c 文件中的实现一一对应。

// 滥用头文件
// 将实现代码直接写在头文件中可能导致代码冗余和重复定义。
// 解决方法： ① 在头文件中只写声明，将实现放在 .c 文件中。

// 综上。头文件在 C 语言中是实现模块化编程的重要工具。通过合理使用头文件，可以提高代码的复用性、可读性和维护性。在实际开发中应注意以下几点：

// 将声明（函数、宏、数据类型）放在头文件中，将实现放在 .c 文件中。
// 使用头文件保护机制避免重复包含。
// 合理拆分和组织头文件，避免头文件之间的过度耦合。
// 熟悉并善用 C 标准库 的头文件，减少重复造轮子。
// 头文件的正确使用不仅能提高代码质量，还能让团队协作更加高效。下面，我用在实际开发中的项目管理，看看头文件在开发里的实际作用：

// 在大型项目中，合理组织头文件是实现模块化设计、团队协作和代码复用的关键。
// 头文件的组织需要遵循一定的规则，以确保项目的结构清晰、依赖关系明确，并避免重复包含和命名冲突的问题。
// 我们这里通过一个示例来说明如何在大型项目中组织头文件。

// 项目结构设计
// 1. 项目目录结构
// 在大型项目中，通常将头文件和源文件按照模块或功能分类，并将头文件放在一个专门的目录下。例如：

// MyProject/
// ├── include/               // 头文件目录
// │   ├── module1/           // 模块1相关头文件
// │   │   ├── module1.h
// │   │   └── utils1.h
// │   ├── module2/           // 模块2相关头文件
// │   │   ├── module2.h
// │   │   └── utils2.h
// │   └── common/            // 公共头文件
// │       ├── config.h
// │       └── macros.h
// ├── src/                   // 源文件目录
// │   ├── module1/
// │   │   ├── module1.c
// │   │   └── utils1.c
// │   ├── module2/
// │   │   ├── module2.c
// │   │   └── utils2.c
// │   └── main.c
// ├── build/                 // 编译输出目录
// ├── Makefile               // 构建脚本
// └── README.md              // 项目说明文件

// 2. 头文件命名规则
// 模块化命名：头文件应以模块命名，避免与其他模块或标准库头文件冲突。例如：

// module1.h 表示模块1的主头文件。
// utils1.h 表示模块1的工具函数头文件。
// 公共头文件：将项目中的全局配置、宏、数据类型定义等公共内容放在 common/ 目录下，如 config.h 和 macros.h。

// 头文件的内容组织
// 1. 主模块头文件
// 主要提供模块的外部接口声明，供其他模块使用。（系统提供的头文件通常以 _开头，自己写的头文件通常以__开头，防止重复定义）
// 只包含必要的内容，隐藏模块内部实现细节。

// // module1.h
// #ifndef __MODULE1_H
// #define __MODULE1_H

// #include <stdio.h>  // 标准库头文件
// #include "common/config.h"  // 项目公共头文件

// // 模块1对外的函数声明
// void module1_init();
// void module1_process();

// #endif  // __MODULE1_H

// 此处出现了文章开头的问题： <stdio.h> 和 "stdio.h" 这两种写法皆可行吗？为什么？这二者有何区别呢？
// #include <stdio.h> // 标准库头文件 和 #include "common/config.h" // 项目公共头文件

// <> 和 "" ：
// <>：根据系统提供的路径去寻找头文件（/usr/include）；
// "" ：根据自己提供的路径去寻找头文件，如果没有找到，再去系统提供的路径下寻找。
// 因此，引用头文件时，<stdio.h> 和 "stdio.h" 两种写法都可行，但一般情况下，我们仍然使用 <> 引用，
// 因为使用 ""引用时，如果在自己提供的路径中未找到头文件，又会重新在系统路径下再寻找一次，额外消耗了性能，这么做性价比不高，
// 所以，使用系统标准库头文件时均使用 <> 引用。例如，最常使用的 #include <stdio.h>：

// stdio.h （英语：standard input/output header，标准输入/输出头文件）是C语言为输入输出提供的标准库头文件，
// 其前身是迈克·莱斯克20世纪70年代编写的“可移植输入输出程序库”。
// C语言中的所有输入和输出都由抽象的字节流来完成，对文件的访问也通过关联的输入或输出流进行。

// 2. 工具函数头文件
// 定义模块内部使用的工具函数或辅助功能，通常不直接对外暴露。

// // utils1.h
// #ifndef __UTILS1_H
// #define __UTILS1_H

// // 模块1内部工具函数
// int helper_function(int a, int b);

// #endif  // __UTILS1_H

// 3. 公共头文件
// 定义整个项目的全局配置、数据类型、宏和其他公共内容。
// 这些头文件通常被多个模块共享。

// // config.h
// #ifndef __CONFIG_H
// #define __CONFIG_H

// // 项目全局配置
// #define MAX_BUFFER_SIZE 1024
// #define PROJECT_NAME "MyProject"

// #endif  // __CONFIG_H

// // macros.h
// #ifndef __MACROS_H
// #define __MACROS_H

// // 常用宏定义
// #define SQUARE(x) ((x) * (x))
// #define MAX(a, b) ((a) > (b) ? (a) : (b))

// #endif  // __MACROS_H

// 头文件的相互引用
// 1. 避免循环依赖

// 在大型项目中，头文件可能会相互包含，导致循环依赖问题（A.h 引用 B.h，而 B.h 又引用 A.h）。为避免此问题：

// 1.使用前向声明（Forward Declarations）代替直接包含头文件。
// 2.仅在需要完整类型定义时包含相关头文件。

// // module2.h
// #ifndef __MODULE2_H
// #define __MODULE2_H

// #include "common/config.h"

// // 使用前向声明避免包含 module1.h
// struct Module1;

// // 模块2对外接口
// void module2_process(struct Module1* module1_instance);

// #endif  // __MODULE2_H

// 示例：模块间协作
// 以下是一个完整的示例，展示如何组织和使用头文件和源文件。（结合上图更容易理解）

// 1.module1.h

// #ifndef __MODULE1_H
// #define __MODULE1_H

// #include <stdio.h>

// // 模块1的初始化函数
// void module1_init();

// #endif  // __MODULE1_H

// 2.module1.c

// #include "module1.h"

// void module1_init() {
//     printf("Module 1 initialized.\n");
// }

// 3.module2.h

// #ifndef __MODULE2_H
// #define __MODULE2_H

// #include "module1.h"

// // 模块2的处理函数
// void module2_process();

// #endif  // __MODULE2_H

// 4.module2.c

// #include "module2.h"

// void module2_process() {
//     module1_init();  // 调用模块1的函数
//     printf("Module 2 processing.\n");
// }

// 5.main.c （主函数）

// #include "module2.h"

// int main() {
//     module2_process();
//     return 0;
// }

// 编译与运行
// 使用 gcc 进行编译和链接：

// gcc -Iinclude src/module1.c src/module2.c src/main.c -o MyProject

// 运行程序：

// ./MyProject

// 输出：

// Module 1 initialized.
// Module 2 processing.

// 综上。在项目中头文件的组织是非常重要的环节之一：

// 模块化设计：每个模块有自己的头文件，头文件只暴露必要的接口。
// 公共头文件独立管理：将公共配置、宏和常量集中放置在 include/common/ 目录下。
// 避免重复包含：使用头文件保护（#ifndef...#define 或 #pragma once）。
// 减少头文件依赖：使用前向声明避免不必要的头文件包含。
// 按需包含：仅在需要的源文件中包含头文件，避免头文件之间的过度耦合。
// 因此，通过合理组织头文件，可以让大型项目的结构更加清晰，团队协作更加高效，同时减少调试和维护的复杂度。

// ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

// .h文件与.c文件的关系

// 参考高手的程序时，发现别人写的严格的程序都带有一个“KEY.H”，
// 里面定义了.C文件里用到的自己写的函数，如Keyhit()、Keyscan()等。
// .H文件就是头文件，估计就是Head的意思吧，这是规范程序结构化设计的需要，既可以实现大型程序的模块化，又可以实现根各模块的连接调试。

// .H文件介绍：

// 在单片机嵌入式C程序设计中，项目一般按功能模块化进行结构化设计。
// 将一个项目划分为多个功能，每个功能的相关程序放在一个C程序文档中，称之为一个模块，对应的文件名即为模块名。
// 一个模块通常由两个文档组成，一个为头文件*.h，对模块中的数据结构和函数原型进行描述;
// 另一个则为C文件*.c ，对数据实例或对象定义，以及函数算法具体实现。

// .H文件的作用

// 作为项目设计，除了对项目总体功能进行详细描述外，就是对每个模块进行详细定义，也就是给出所有模块的头文件。
// 通常H头文件要定义模块中各函数的功能，以及输入和输出参数的要求。模块的具体实现，由项目组成根据H文件进行设计、编程、调试完成。
// 为了保密和安全，模块实现后以可连接文件OBJ、或库文件LIB的方式提供给项目其他成员使用。
// 由于不用提供源程序文档，一方面可以公开发行，保证开发人员的所有权;
// 另一方面可以防止别人有意或无意修改产生非一致性，造成版本混乱。
// 所以H头文件是项目的详细设计和团队工作划分的依据，也是对模块进行测试的功能说明。
// 要引用模块内的数据或算法，只要用包含include指定模块H头文件即可。

// .H文件的基本组成

// /*如下为键盘驱动的头文档*/
// #ifndef _KEY_H_ //防重复引用，如果没有定义过_KEY_H_，则编译下句
// #define _KEY_H_ //此符号唯一， 表示只要引用过一次，即#i nclude，则定义符号_KEY_H_
// /////////////////////////////////////////////////////////////////

// char keyhit( void ); //击键否

// unsigned char Keyscan( void ); //取键值

// /////////////////////////////////////////////////////////////////
// #endif
// 尽量使用宏定义#define

// 开始看别人的程序时，发现程序开头，在文件包含后面有很多#define语句，
// 当时就想，搞这么多标示符替换来替换去的，麻不麻烦啊，完全没有理解这种写法的好处。
// 原来，用一个标示符表示常数，有利于以后的修改和维护，修改时只要在程序开头改一下，程序中所有用到的地方就全部修改，节省时间。

// #define KEYNUM 65//按键数量，用于Keycode[KEYNUM]
// #define LINENUM 8//键盘行数
// #define ROWNUM 8//键盘列数
// 注意的地方：

// 宏名一般用大写
// 宏定义不是C语句，结尾不加分号
// 不要乱定义变量类型

// 以前写程序，当需要一个新的变量时，不管函数内还是函数外的，直接在程序开头定义，虽然不是原则上的错误，但是很不可取的作法。
// 下面说一下，C语言中变量类型的有关概念。从变量的作用范围来分，分为局部变量和全局变量：

// 全局变量：是在函数外定义的变量，全局变量在程序全部执行过程中都占用资源，全局变量过多使程序的通用性变差，因为全局变量是模块间耦合的原因之一。

// 局部变量：在函数内部定义的变量，只在函数内部有效。

// 从变量的变量值存在的时间分为两种：

// 静态存储变量：程序运行期间分配固定的存储空间。

// 动态存储变量：程序运行期间根据需要动态地分配存储空间。

// 具体又包括四种存储方式：

// auto

// static

// register

// extern

// 不加说明默认为auto型，即动态存储，如果不赋初值，将是一个不确定的值。
// 而将局部变量定义为static型的话，则它的值在函数内是不变的，且初值默认为0。
// 编译时分配为静态存储区，可以被本文件中的各个函数引用。
// 如果是多个文件的话，如果在一个文件中引用另外文件中的变量，在此文件中要用extern说明。
// 不过如果一个全局变量定义为static的话，就只能在此一个文件中使用。
// register定义寄存器变量，请求编译器将这个变量保存在CPU的寄存器中，从而加快程序的运行。

// 特殊关键字const volatile的使用

// const

// const用于声明一个只读的变量。

// const unsigned char a=1;//定义a=1，编译器不允许修改a的值
// 作用：保护不希望被修改的参数。

// volatile

// 一个定义为volatile的变量是说这变量可能会被意想不到地改变,这样,编译器就不会去假设这个变量的值了。
// 精确地说就是,优化器在用到这个变量时必须每次都小心地重新读取这个变量的值,而不是使用保存在寄存器里的备份。

// static int i=0;
// int main(void)
// {
// ...
// while (1)
// {
// if (i)
// dosomething();
// }
// }
// /* Interrupt service routine. */
// void ISR_2(void)
// {
// i=1;
// }
// 程序的本意是希望ISR_2中断产生时，在main当中调用dosomething函数，
// 但是，由于编译器判断在main函数里面没有修改过i，因此可能只执行一次对从i到某寄存器的读操作,
// 然后每次if判断都只使用这个寄存器里面的“i副本”，导致dosomething永远也不会被调用。
// 如果将将变量加上volatile修饰,则编译器保证对此变量的读写操作都不会被优化(肯定执行)。

// 一般说来,volatile用在如下的几个地方：

// 中断服务程序中修改的供其它程序检测的变量需要加volatile；
// 多任务环境下各任务间共享的标志应该加volatile；
// 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义。