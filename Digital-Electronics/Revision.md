### **幻灯片 3: 不同数字系统之间的转换 (Conversion between different number systems)**

---

#### **1. 将 (40)₁₀ 转换为二进制 (Convert (40)₁₀ to binary)**
**方法：** 连续除以2，取余数，由下往上读。

*   40 ÷ 2 = 20 ... 余数 0
*   20 ÷ 2 = 10 ... 余数 0
*   10 ÷ 2 = 5  ... 余数 0
*   5  ÷ 2 = 2  ... 余数 1
*   2  ÷ 2 = 1  ... 余数 0
*   1  ÷ 2 = 0  ... 余数 1

**答案：** (101000)₂

---

#### **2. 将 (23)₁₀ 转换为二进制 (Convert (23)₁₀ to binary)**
**方法：** 同上。

*   23 ÷ 2 = 11 ... 余数 1
*   11 ÷ 2 = 5  ... 余数 1
*   5  ÷ 2 = 2  ... 余数 1
*   2  ÷ 2 = 1  ... 余数 0
*   1  ÷ 2 = 0  ... 余数 1

**答案：** (10111)₂

---

#### **3. 将 (10101100)₂ 转换为十进制 (Convert (10101100)₂ to decimal)**
**方法：** 将每个二进制数字乘以其对应的权重 (2 的次方)，然后相加。

*   (1 × 2⁷) + (0 × 2⁶) + (1 × 2⁵) + (0 × 2⁴) + (1 × 2³) + (1 × 2²) + (0 × 2¹) + (0 × 2⁰)
*   = 128 + 0 + 32 + 0 + 8 + 4 + 0 + 0
*   = 172

**答案：** (172)₁₀

---

#### **4. 将 (00101001)₂ 转换为十进制 (Convert (00101001)₂ to decimal)**
**方法：** 同上。前面的 0 不影响数值。

*   (0 × 2⁷) + (0 × 2⁶) + (1 × 2⁵) + (0 × 2⁴) + (1 × 2³) + (0 × 2²) + (0 × 2¹) + (1 × 2⁰)
*   = 0 + 0 + 32 + 0 + 8 + 0 + 0 + 1
*   = 41

**答案：** (41)₁₀

***

### **幻灯片 4: 二进制计算 (Binary calculations)**

---

#### **1. 10110 + 1001**
**方法：** 对齐数字，从右到左逐位相加，逢二进一。

```
  10110   (十进制: 22)
+  01001   (十进制: 9)
-------
  11111   (十进制: 31)
```

**答案：** 11111

---

#### **2. 0.11011 + 0.00110**
**方法：** 小数点对齐，然后进行加法。为了方便，可以在末尾补0。

```
  0.11011
+ 0.00110
---------
  1.00001
```
*   **最右位:** 1 + 0 = 1
*   **右二位:** 1 + 1 = 10 (写 0, 进 1)
*   **右三位:** 0 + 1 + 1 (进位) = 10 (写 0, 进 1)
*   **右四位:** 1 + 0 + 1 (进位) = 10 (写 0, 进 1)
*   **右五位:** 1 + 0 + 1 (进位) = 10 (写 0, 进 1 到整数位)

**答案：** 1.00001

---

#### **3. 10001 × 1101**
**方法：** 类似十进制乘法，产生部分积，然后相加。

```
        10001      (十进制: 17)
      ×  1101      (十进制: 13)
      -------
        10001      (10001 * 1)
       00000       (10001 * 0, 左移一位)
      10001        (10001 * 1, 左移两位)
+   10001          (10001 * 1, 左移三位)
------------------
    11011101     (十进制: 221)
```

**答案：** 11011101

***

### **幻灯片 5: 使用二补数的二进制减法 (Binary subtraction using 2's complement)**

---

#### **10110 – 1001**
**方法：** A - B = A + (-B)。首先找到 B 的二补数，然后将其与 A 相加。

1.  **统一位数 (Equalize bits):**
    *   A = 10110 (5 位)
    *   B = 1001 -> 01001 (补齐为 5 位)

2.  **找 B 的反码 (1's complement):** 反转所有位。
    *   01001 的反码是 10110。

3.  **找 B 的补码 (2's complement):** 反码加 1。
    *   10110 + 1 = 10111

4.  **将 A 与 B 的补码相加 (Add A and the 2's complement of B):**
    ```
      10110
    + 10111
    -------
    1 01101
    ```

5.  **解读结果 (Interpret the result):** 由于最高位产生了进位 (carry-out)，表示结果为正数。舍弃此进位。

**答案：** 01101 (即 1101)。
*   **验证:** (22)₁₀ - (9)₁₀ = (13)₁₀。 (1101)₂ = 8 + 4 + 0 + 1 = 13。

***

### **幻灯片 6: 周期、频率与占空比 (Period, frequency and duty cycle)**

---

**分析波形 (Analyzing the waveform):**
*   信号在 2 ns 时从低电平变为高电平。
*   信号在 6 ns 时从高电平变为低电平。
*   下一个周期的上升沿在 9 ns。

1.  **周期 (Period, T):** 一个完整循环所需的时间。
    *   T = 9 ns - 2 ns = 7 ns

2.  **频率 (Frequency, f):** 周期的倒数。
    *   f = 1 / T = 1 / (7 ns) = 1 / (7 × 10⁻⁹ s) ≈ 142.86 × 10⁶ Hz = 142.86 MHz

3.  **占空比 (Duty Cycle, %):** 信号为高电平的时间 (脉冲宽度) 占总周期的百分比。
    *   脉冲宽度 (Pulse width, t_high) = 6 ns - 2 ns = 4 ns
    *   占空比 = (t_high / T) × 100% = (4 ns / 7 ns) × 100% ≈ 57.14%

**答案：**
*   **周期:** 7 ns
*   **频率:** ~142.86 MHz
*   **占空比:** ~57.14%

***

### **幻灯片 7: 使用布尔代数简化表达式 (Expression simplification using Boolean algebra)**

---

**X = (ĀB(Č + BD) + AC)B**

**注意：** 幻灯片中的手写解答似乎基于一个不同的表达式或在推导中存在错误。我们将严格按照打印出的题目进行简化。

1.  **分配律 (Distributive Law):** 将括号外的 B 乘进去。
    *   X = ĀB(Č + BD)B + AC(B)

2.  **结合律 (Associative Law) & 等幂律 (Idempotent Law):** BB = B
    *   X = ĀB(Č + BD) + ABC

3.  **分配律 (Distributive Law):** 将 ĀB 乘进去。
    *   X = ĀBČ + ĀB(BD) + ABC

4.  **结合律 & 等幂律:** ĀB(BD) = Ā(BB)D = ĀBD
    *   X = ĀBČ + ĀBD + ABC

5.  **提取公因式 (Factoring):**
    *   X = ĀB(Č + D) + ABC

这个表达式无法再通过基础的布尔代数定律进行进一步简化。它已经是简化的“和之积” (SOP) 形式之一。

***

### **幻灯片 8: 转换为标准SOP与完成真值表 (Convert to standard SOP and complete truth table)**

---

**X = ĀC + B̄C + BC**

1.  **首先简化表达式 (Simplify the expression first):**
    *   使用邻接律 (Adjacency Law): B̄C + BC = C(B̄ + B) = C(1) = C
    *   所以, X = ĀC + C

2.  **吸收律 (Absorption Law):** Y + ȲX = Y + X. 这里， C + ĀC 可以看作 Y + XȲ 的形式，其中 Y=C, X=Ā。
    *   C + ĀC = C + Ā
    *   所以, **X = Ā + C** (这是最简形式)

3.  **转换为标准SOP (Expand to Standard SOP):** 标准SOP的每个乘积项必须包含所有变量 (A, B, C)。
    *   **展开 Ā:**
        *   Ā = Ā(B + B̄) = ĀB + ĀB̄
        *   ĀB = ĀB(C + Č) = ĀBC + ĀBČ
        *   ĀB̄ = ĀB̄(C + Č) = ĀB̄C + ĀB̄Č
        *   所以, Ā = ĀBC + ĀBČ + ĀB̄C + ĀB̄Č
    *   **展开 C:**
        *   C = C(A + Ā) = AC + ĀC
        *   AC = AC(B + B̄) = ABC + AB̄C
        *   ĀC = ĀC(B + B̄) = ĀBC + ĀB̄C
        *   所以, C = ABC + AB̄C + ĀBC + ĀB̄C

4.  **合并结果并去除重复项 (Combine and remove duplicates):**
    *   X = (ĀBC + ĀBČ + ĀB̄C + ĀB̄Č) + (ABC + AB̄C + ĀBC + ĀB̄C)
    *   **X = ABC + AB̄C + ĀBC + ĀB̄C + ĀBČ + ĀB̄Č**

**真值表 (Truth Table for X = Ā + C):**

| A | B | C | X |
|---|---|---|:-:|
| 0 | 0 | 0 | 1 |
| 0 | 0 | 1 | 1 |
| 0 | 1 | 0 | 1 |
| 0 | 1 | 1 | 1 |
| 1 | 0 | 0 | 0 |
| 1 | 0 | 1 | 1 |
| 1 | 1 | 0 | 0 |
| 1 | 1 | 1 | 1 |

***

### **幻灯片 9 & 10: 使用卡诺图寻找简化的SOP表达式 (Karnaugh Maps to find simplified SOP)**

---

**注意：** 幻灯片 9 的表达式与幻灯片 10 的卡诺图不完全匹配。我们将根据幻灯片 10 中给出的卡诺图进行简化。

**分析幻灯片 10 的卡诺图 (Analyzing the K-Map on Slide 10):**
*   **1 的位置 (Positions of 1s):**
    *   AB=01, CD=00, 01, 11, 10
    *   AB=11, CD=11
    *   AB=10, CD=00, 11, 10

1.  **圈组 1 (Group 1 - 红色):** 最大的组合是一个包含 4 个 "1" 的整行 (AB=01)。
    *   在这个组里，C 和 D 都在变化，因此被消去。
    *   A=0, B=1 保持不变。
    *   **项: ĀB**

2.  **圈组 2 (Group 2 - 蓝色):** 一个包含 2 个 "1" 的竖列，位于 (AB=01, CD=11) 和 (AB=11, CD=11)。
    *   变量 A 在 0 和 1 之间变化，被消去。
    *   B=1, C=1, D=1 保持不变。
    *   **项: BCD**

3.  **圈组 3 (Group 3 - 绿色):** 一个包含 2 个 "1" 的组合，位于 (AB=10, CD=10) 和 (AB=10, CD=11)。
    *   变量 C 在 0 和 1 之间变化，被消去。
    *   A=1, B=0, D=1 保持不变。
    *   **项: AB̄D**

4.  **圈组 4 (Group 4 - 黄色):** 一个由两端相邻的 "1" 构成的组合，位于 (AB=10, CD=00) 和 (AB=10, CD=10)。
    *   变量 D 在 0 和 1 之间变化，被消去。
    *   A=1, B=0, C=0 保持不变。
    *   **项: AB̄Č**

**合并所有项得到最终的简化表达式 (Combine all terms for the final simplified expression):**
**F = ĀB + BCD + AB̄D + AB̄Č**

***

### **幻灯片 11: 实现逻辑电路 (Implementing logic circuits)**

---

**仅使用与非门 (NAND) 实现 X = A̅B̅ + C̅D̅**

**注意：** 幻灯片中的标题与手绘图不符。手绘图实现的是 `X = AB + CD`。我们将按照标题 `X = A̅B̅ + C̅D̅` 进行设计。

**方法：** 使用德摩根定律，任何“与-或”逻辑都可以转换为“与非-与非”逻辑。

1.  **双重取反 (Double Negation):** 在整个表达式上加两条反相横线。
    *   X = (A̅B̅ + C̅D̅)''

2.  **应用德摩根定律 (Apply De Morgan's Theorem):** 将下面的长横线断开，并将 OR (+) 变为 AND (⋅)。
    *   X = ( (A̅B̅)' ⋅ (C̅D̅)' )'

3.  **解读电路 (Interpret the circuit):**
    *   `(A̅B̅)'` 是一个与非门，输入为 A̅ 和 B̅。
    *   `(C̅D̅)'` 是一个与非门，输入为 C̅ 和 D̅。
    *   这两个与非门的输出，再共同作为第三个与非门的输入。
    *   如果电路的原始输入只能是 A, B, C, D，我们还需要用与非门来构造非门 (NOT)。
        *   A̅ = (A ⋅ A)' (将与非门的两个输入端连在一起)。

**电路实现步骤 (Circuit Implementation Steps):**
1.  **与非门 1:** 输入 A, A -> 输出 A̅
2.  **与非门 2:** 输入 B, B -> 输出 B̅
3.  **与非门 3:** 输入 C, C -> 输出 C̅
4.  **与非门 4:** 输入 D, D -> 输出 D̅
5.  **与非门 5:** 输入 A̅, B̅ -> 输出 (A̅B̅)'
6.  **与非门 6:** 输入 C̅, D̅ -> 输出 (C̅D̅)'
7.  **与非门 7:** 输入 (A̅B̅)' 和 (C̅D̅)' -> 输出 X

***

### **幻灯片 12: 锁存器或触发器的输出波形 (Output waveform of a latch or flip-flop)**

---

**分析 (Analysis):**
*   **类型:** 正边沿触发 JK 触发器 (Positive edge-triggered JK flip-flop)。
*   **异步输入:** PRE (PRESET) 和 CLR (CLEAR) 都是低电平有效 (active-low)。这意味着当它们为 0 时，会立即强制输出，而无需等待时钟信号。PRE=0 使 Q=1，CLR=0 使 Q=0。
*   **JK 功能表 (JK Function Table) (在时钟上升沿):**
    *   J=0, K=0: 保持 (Hold)
    *   J=0, K=1: 复位 (Reset, Q=0)
    *   J=1, K=0: 置位 (Set, Q=1)
    *   J=1, K=1: 翻转 (Toggle, Q -> Q')

**波形追踪 (Waveform Tracing):** (假设 Q 初始为 0)

1.  **开始 -> 第1个CLK上升沿前:** PRE=1, CLR=1 (无效)。Q 保持初始状态 0。
2.  **第1个CLK上升沿:** J=1, K=0 (置位)。Q 从 0 变为 1。
3.  **第2个CLK上升沿前:** CLR 信号变为 0。这是异步清零，Q 立即被强制复位为 0。
4.  **第2个CLK上升沿:** 尽管 J=1, K=0，但 CLR=0 的异步操作优先级更高，因此 Q 保持为 0。
5.  **CLR恢复为1后:** Q 保持为 0，直到下一个时钟边沿。
6.  **第3个CLK上升沿:** J=1, K=1 (翻转)。Q 从 0 变为 1。
7.  **第4个CLK上升沿:** J=0, K=1 (复位)。Q 从 1 变为 0。
8.  **第5个CLK上升沿:** J=1, K=0 (置位)。Q 从 0 变为 1。
9.  **第6个CLK上升沿:** J=1, K=1 (翻转)。Q 从 1 变为 0。

**结论:** 幻灯片中绿色的 Q 输出波形是正确的，它准确地反映了 JK 输入、时钟边沿以及 PRE/CLR 异步控制的综合作用。