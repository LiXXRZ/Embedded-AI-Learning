### **Fundamentals of Digital Electronics – Finite State Machines**
### **数字电子技术基础 – 有限状态机**

---

#### **1. Recap: Foundational Memory Elements (回顾：基础存储元件)**

*   **The SR Latch (SR 锁存器)**:
    *   **Function (功能)**: The most basic memory element. It can store a single bit of information (0 or 1).
        最基本的存储元件，可以存储一位信息（0 或 1）。
    *   **"Illegal State" (非法状态)**: When both inputs S=1 and R=1, both outputs Q and Q' are forced to 0. This state is problematic because:
        当输入 S=1 且 R=1 时，两个输出 Q 和 Q' 都被强制为 0。这个状态是有问题的，因为：
        1.  It violates the fundamental rule that Q should be the inverse of Q'.
            它违反了 Q 应该是 Q' 反相的基本规则。
        2.  If S and R then switch to 0 simultaneously, the final state of Q is unpredictable (it can race to either 0 or 1).
            如果 S 和 R 接着同时变为 0，Q 的最终状态是不可预测的（它可能竞争变为 0 或 1）。
    *   **Logic Table (逻辑表)**:
        ```
        S | R | Q(next) | Q'(next) | Comment
        --|---|---------|----------|----------
        0 | 0 | Q       | Q'       | Hold (保持)
        0 | 1 | 0       | 1        | Reset (复位)
        1 | 0 | 1       | 0        | Set (置位)
        1 | 1 | 0       | 0        | Illegal (非法)
        ```

*   **Triggering Methods (触发方式)**:
    *   **Latch (锁存器)**: **Level Triggered (电平触发)**. The output can change at any time the enable signal (e.g., clock) is at its active level. This property is called "transparency."
        输出可以在使能信号（例如时钟）处于其有效电平的任何时候改变。这种特性被称为“透明性”。
    *   **Flip-Flop (触发器)**: **Edge Triggered (边沿触发)**. The output changes *only* at the precise moment of a clock transition (either from low-to-high 📈 for positive-edge, or high-to-low 📉 for negative-edge). This ensures all state changes in a system happen in perfect synchronization.
        输出*仅*在时钟转换的精确瞬间改变（对于正边沿是低到高 📈，对于负边沿是高到低 📉）。这确保了系统中所有的状态变化都完美同步地发生。

*   **The D-Type Flip-Flop (D 型触发器)**:
    *   **Purpose (目的)**: To eliminate the illegal state of the SR latch. It has only one data input, D.
        消除 SR 锁存器的非法状态。它只有一个数据输入 D。
    *   **Internal Logic (内部逻辑)**: It is constructed from an SR flip-flop where the inputs are driven by D: `S = D` and `R = NOT(D)`. This guarantees S and R are never both 1 at the same time.
        它由一个 SR 触发器构建，其输入由 D 驱动：`S = D` 且 `R = NOT(D)`。这保证了 S 和 R 永远不会同时为 1。
    *   **Function (功能)**: On the active clock edge, the value at the D input is transferred to the Q output. `Q(next) = D`.
        在有效的时钟沿，D 输入端的值被传输到 Q 输出端。`Q(下一状态) = D`。

*   **Asynchronous Inputs (异步输入)**:
    *   **PRESET (预置)** & **CLEAR (清零)**: These inputs override the clock and all other inputs. They are used to force the flip-flop into a known state (PRESET forces Q=1, CLEAR forces Q=0) for initialization.
        这些输入会覆盖时钟和所有其他输入。它们用于将触发器强制到一个已知的状态（PRESET 强制 Q=1，CLEAR 强制 Q=0）以进行初始化。

---

#### **2. Finite State Machine (FSM) Concept (有限状态机概念)**

An FSM is a computational model consisting of a finite number of states. It's defined by its list of states, its initial state, and the conditions for each transition.
FSM 是一种由有限数量状态组成的计算模型。它由其状态列表、初始状态以及每个转换的条件来定义。

*   **Core Components (核心组件)**:
    *   **States (S)**: A finite set of conditions the machine can be in. (例如: {Locked, Unlocked})。
        机器可以处于的一组有限的条件。 (e.g., {锁定, 解锁})。
    *   **Inputs (I)**: The set of signals that influence state transitions. (例如: {Coin, Push})。
        影响状态转换的信号集合。 (e.g., {投币, 推})。
    *   **Outputs (O)**: The set of signals generated by the machine. (例如: {Green Arrow, Red Cross})。
        由机器生成的信号集合。 (e.g., {绿箭头, 红叉})。
    *   **Transition Function (δ)**: Determines the next state based on the current state and inputs.
        根据当前状态和输入来决定下一个状态。
        `Next State = δ(Current State, Inputs)`
    *   **Output Function (λ)**: Determines the outputs. This function defines the FSM type.
        决定输出。这个函数定义了 FSM 的类型。

---

#### **3. Types of FSM: Mealy vs. Moore Machines (FSM 的类型：Mealy 机与 Moore 机)**

This is a critical distinction based on the output function λ.
这是一个基于输出函数 λ 的关键区别。

| Feature (特征) | Moore Machine (Moore 机) | Mealy Machine (Mealy 机) |
| :--- | :--- | :--- |
| **Output Logic (输出逻辑)** | Output depends **only** on the **current state**. | Output depends on **both** the **current state AND current inputs**. |
| **Output Formula (输出公式)** | `Output = λ(Current State)` | `Output = λ(Current State, Inputs)` |
| **State Diagram (状态图)** | Output is written **inside the state circle**. (输出写在**状态圈内部**)<br> `(State / Output)` | Output is written **on the transition arc**. (输出写在**转换弧上**)<br> `Input / Output` |
| **Timing (时序)** | Outputs change synchronously with state transitions (after a clock edge). This may introduce a 1-cycle delay. (输出与状态转换同步改变（在时钟沿之后）。这可能会引入一个周期的延迟。) | Outputs can change immediately and asynchronously in response to input changes. This offers a faster response but can cause glitches. (输出可以响应输入的变化而立即异步改变。这提供了更快的响应，但可能导致毛刺。) |
| **Example Diagram (图例)** | <pre> (S0 / 0) ---Input 1---> (S1 / 1) </pre> | <pre> S0 ---Input 1 / Output 1---> S1 </pre> |

---

#### **4. FSM Design Process: From Concept to Circuit (FSM 设计流程：从概念到电路)**

**Step 1: Capture Behaviour (捕获行为)**
1.  **State Diagram (状态图)**: Visualize the states and transitions. For the laser example:
    可视化状态和转换。以激光器为例：
    ```
         +------- b=0 --------+
         |                    |
    ---> ( Off/x=0 ) --b=1--> ( On1/x=1 ) --+--> ( On2/x=1 ) --+--> ( On3/x=1 ) --+
                                            |                  |                  |
                                            +------------------+------------------+
    ```
2.  **State Transition Table (状态转换表)**: Formalize the diagram.
    将图表形式化。

| Present State (当前状态) | Input b (输入b) | Next State (下一状态) | Output x (输出x) |
| :--- | :--- | :--- | :--- |
| Off | 0 | Off | 0 |
| Off | 1 | On1 | 0 |
| On1 | X | On2 | 1 |
| On2 | X | On3 | 1 |
| On3 | X | Off | 1 |

**Step 2: Convert to Circuit (转换为电路)**
1.  **State Encoding (状态编码)**: Assign unique binary codes. The number of bits needed `n` is `n = ⌈log₂(number of states)⌉`. For 4 states, we need `⌈log₂(4)⌉ = 2` bits.
    分配唯一的二进制代码。所需位数 `n` 为 `n = ⌈log₂(状态数)⌉`。对于 4 个状态，我们需要 `⌈log₂(4)⌉ = 2` 位。
    *   Off: `s1s0 = 00`
    *   On1: `s1s0 = 01`
    *   On2: `s1s0 = 10`
    *   On3: `s1s0 = 11`

2.  **Derive Truth Table (推导真值表)**: Combine the transition table and encoding. `n1n0` are the next state bits.
    结合转换表和编码。`n1n0` 是下一状态位。

| s1 | s0 | b | n1 | n0 | x |
|:--:|:--:|:-:|:--:|:--:|:-:|
| 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 0 | 1 | 0 |
| 0 | 1 | X | 1 | 0 | 1 |
| 1 | 0 | X | 1 | 1 | 1 |
| 1 | 1 | X | 0 | 0 | 1 |

3.  **Find Boolean Equations (求解布尔方程)**: From the truth table, derive logic for each output and next-state bit. (From slide 24)
    从真值表中，为每个输出和下一状态位推导逻辑。（来自幻灯片 24）
    *   `x = s1 + s0`
    *   `n1 = s1's0 + s1s0' = s1 ⊕ s0` (XOR)
    *   `n0 = s1's0'b + s1s0'`

4.  **Implement Circuit Architecture (实现电路架构)**:
    *   **State Register (状态寄存器)**: 2 D-type flip-flops to store the current state bits `s1` and `s0`.
        2 个 D 型触发器用于存储当前状态位 `s1` 和 `s0`。
    *   **Combinational Logic (组合逻辑)**: Gates to implement the equations for `x`, `n1`, and `n0`.
        实现 `x`, `n1`, 和 `n0` 方程的逻辑门。

    **Conceptual Diagram (概念图)**:
    ```
                   +-----------------------+
    System Inputs --->|  Combinational Logic  | ---> System Outputs (x)
         (b)        |       (Gates)         |
                    +-----------------------+
                        ^            |
                        | Next State |
                        | (n1, n0)   |
          +-------------+------------+
          |             |
          v             |
    +-----------+   Current State
    | D FF (s1) |-----> (s1)
    | D FF (s0) |-----> (s0)
    +-----------+
         ^
         |
        CLK
    ```

---

### **Counters and Registers (第 9 讲：计数器和寄存器)**

---

#### **1. Types of Counters (计数器的类型)**

**Asynchronous (Ripple) Counter (异步（脉动）计数器)**
*   **Structure (结构)**: No common clock. The output of one flip-flop clocks the next.
    没有共同时钟。一个触发器的输出作为下一个触发器的时钟。
    `CLK ➡️ [FF0] --Q0--> CLK_in [FF1] --Q1--> CLK_in [FF2] ...`
*   **Propagation Delay (传播延迟)**: The main disadvantage. The total delay is the sum of individual delays, limiting the maximum frequency.
    主要缺点。总延迟是单个延迟的总和，这限制了最大频率。
    `t_total_delay = N × t_pd`
    (where `N` = number of flip-flops, `t_pd` = propagation delay of one flip-flop)
    （其中 `N` = 触发器数量, `t_pd` = 单个触发器的传播延迟）

**Synchronous Counter (同步计数器)**
*   **Structure (结构)**: All flip-flops share a common clock. Additional logic determines which flip-flops toggle.
    所有触发器共享一个共同时钟。附加的逻辑决定哪些触发器翻转。
*   **Logic Example (for a 3-bit binary up-counter using J-K FFs) (逻辑示例（使用 J-K 触发器的 3 位二进制加法计数器）)**:
    *   FF0 toggles on every clock pulse: `J₀ = K₀ = 1`
    *   FF1 toggles only when Q0 is 1: `J₁ = K₁ = Q₀`
    *   FF2 toggles only when Q0 and Q1 are both 1: `J₂ = K₂ = Q₀ ⋅ Q₁`
*   **Advantage (优点)**: No cumulative delay. All bits change simultaneously, allowing for much higher speeds.
    没有累积延迟。所有位同时改变，允许更高的速度。

---

#### **2. Applications of Counters (计数器的应用)**

**1. Frequency Division (分频)**
*   **By a Power of 2 (2 的幂次分频)**: The output of the nth flip-flop in a ripple counter divides the clock by 2ⁿ.
    脉动计数器中第 n 个触发器的输出将时钟频率除以 2ⁿ。
    `f_out_n = f_clk / 2^(n+1)` (for the nth FF, starting at n=0)

*   **By an Arbitrary Number N (MOD-N Counter) (任意数 N 分频（MOD-N 计数器）)**:
    *   **Using a Down-Counter (使用减法计数器)**: To divide by N, create a cycle of N states.
        1.  Parallel load the value `N-1` into the counter.
            将值 `N-1` 并行加载到计数器中。
        2.  Let the counter count down.
            让计数器向下计数。
        3.  When the counter reaches zero, the Terminal Count (`tc`) output goes high.
            当计数器达到零时，终端计数 (`tc`) 输出变为高电平。
        4.  Use the `tc` signal to trigger the parallel load (`ld`) on the next clock edge, reloading `N-1`.
            使用 `tc` 信号在下一个时钟沿触发并行加载 (`ld`)，重新加载 `N-1`。
        **Example (Divide by 9)**: Load `9-1=8` (1000). The sequence is 8, 7, 6, 5, 4, 3, 2, 1, 0 (9 states). `tc` pulses every 9 clock cycles.
        **示例（除以 9）**: 加载 `9-1=8` (1000)。序列为 8, 7, 6, 5, 4, 3, 2, 1, 0 (9 个状态)。`tc` 每 9 个时钟周期产生一个脉冲。

    *   **Using an Up-Counter (使用加法计数器)**: To divide by N.
        1.  Let the counter count up from 0.
            让计数器从 0 开始向上计数。
        2.  Use external logic (e.g., an AND gate) to detect when the count reaches `N-1`.
            使用外部逻辑（例如，与门）来检测计数何时达到 `N-1`。
        3.  Use this detection signal to trigger the synchronous clear (`clr`) on the *next* clock pulse.
            使用这个检测信号在*下一个*时钟脉冲时触发同步清零 (`clr`)。
        **Example (Divide by 60)**: Detect count `59` (111011). This signal clears the counter on the 60th clock pulse, returning it to 0. The detection signal itself is the 1 Hz output.
        **示例（除以 60）**: 检测计数值 `59` (111011)。该信号在第 60 个时钟脉冲时清除计数器，使其返回 0。该检测信号本身就是 1 Hz 的输出。

**2. Counter as a Timer (计数器作为计时器)**
*   **Principle (原理)**: Measure time by counting clock pulses of a known period.
    通过计算已知周期的时钟脉冲数来测量时间。
*   **Formula (公式)**:
    `Time = C × T_clk = C / f_clk`
    (where `C` = final count, `T_clk` = clock period, `f_clk` = clock frequency)
    （其中 `C` = 最终计数值, `T_clk` = 时钟周期, `f_clk` = 时钟频率）
*   **Speed Measurement Example (速度测量示例)**:
    1.  **Inputs (输入)**:
        *   Distance between sensors `d` (meters).
        *   Clock frequency `f_clk` (Hz).
    2.  **Process (过程)**:
        *   Start counter when car passes sensor 'a'.
            当汽车通过传感器 'a' 时启动计数器。
        *   Stop counter when car passes sensor 'b'.
            当汽车通过传感器 'b' 时停止计数器。
        *   Read the final count `C`.
            读取最终计数值 `C`。
    3.  **Calculation (计算)**:
        *   Time taken: `t = C / f_clk` (seconds)
        *   Speed: `v = d / t = d / (C / f_clk) = (d × f_clk) / C` (meters/sec)

---

## 🧠 Lecture 8 – Finite State Machines

---

### 1. Recap

**The SR Latch – basic memory element – 1 illegal state.**
SR锁存器——基本存储元件——存在一个非法状态。

**SR Latch with Enable input.**
带有使能输入的SR锁存器。

**Latch is LEVEL triggered; a Flip-flop is EDGE triggered.**
锁存器是电平触发的；触发器是边沿触发的。

**D-type Flip-flop is built from RESET being the complement of SET – i.e., no possibility of Set and Reset at the same time.**
D型触发器由互补的SET与RESET信号构成——即不会同时出现置位和复位。

**Can add PRESET and CLEAR that are asynchronous – they do not depend on the clock.**
可以加入异步的预置（PRESET）和清零（CLEAR）输入——它们不依赖时钟信号。

---

### 2. Objectives

**Understand the concept of state machines.**
理解有限状态机（FSM）的概念。

**Design and analyze the behavior of state machines.**
学习有限状态机的设计与行为分析。

**Be familiar with different types of state machines (Mealy and Moore).**
熟悉两种状态机类型：Mealy机与Moore机。

---

### 3. Finite State Machine Concept

**A finite state machine (FSM) generates a change in response to a clock pulse based on the current state and input conditions.**
有限状态机在每个时钟脉冲下，根据当前状态和输入条件产生状态变化。

**Example – a counter.**
例子——计数器。

**No inputs; transitions occur in response to clock; the behavior is cyclic.**
无外部输入，仅随时钟变化而循环计数。

#### 3-bit Counter State Table

| Current State (A₂ A₁ A₀) | Next State (Y₂ Y₁ Y₀) |
| :----------------------: | :-------------------: |
|            000           |          001          |
|            001           |          010          |
|            010           |          011          |
|            011           |          100          |
|            100           |          101          |
|            101           |          110          |
|            110           |          111          |
|            111           |          000          |

当前状态到下一状态的转换表如上。
这体现了一个三位二进制计数器的循环计数规律。

---

#### Logic Equations for Next State

$$
Y_0 = \overline{A_0} \
Y_1 = A_1 \oplus A_0 \
Y_2 = A_2A_1 + A_2A_0 + A_2A_1A_0
$$

**These equations define how the next state depends on the current state.**
这些公式定义了下一状态如何由当前状态确定。

**Combinational logic computes Y₂ Y₁ Y₀ from A₂ A₁ A₀.**
组合逻辑电路根据当前状态计算下一状态。

**Sequential logic (stored in flip-flops) updates A₂ A₁ A₀ on each clock pulse.**
时序逻辑（触发器存储）在每个时钟脉冲时更新状态。

---

### 4. Finite State Machine Definitions

**Inputs – any stimuli from the external world (often switches or binary sensors).**
输入——来自外界的刺激信号，通常是开关或二进制传感器。

**FSM inputs are usually single-bit signals.**
FSM的输入通常为单比特信号。

**State – describes the current condition of the machine; it is determined by history.**
状态——描述系统当前的条件，由系统的历史决定。

**Outputs – signals linked to the state; may depend on state only (Moore) or on state and input (Mealy).**
输出——与状态相关的信号，可能仅取决于状态（Moore机），或同时取决于状态与输入（Mealy机）。

---

### 5. Mealy and Moore Machines (Overview)

**Moore Machine – output depends only on the current state.**
Moore机——输出仅依赖当前状态。

**Mealy Machine – output depends on both state and input.**
Mealy机——输出依赖于状态和输入。

**Memory elements (flip-flops) store the state bits and update on clock edges.**
存储元件（触发器）存储状态位，并在时钟边沿更新。

---

### 6. Turnstile Example (Practical FSM)

**A turnstile controls access to a subway.**
旋转门用于地铁出入口控制。

**Initially locked; inserting a coin unlocks it; pushing through locks it again.**
初始为锁定状态；投入硬币后解锁；通过后再次锁定。

**Two states:** Locked / Unlocked.
两个状态：锁定 / 解锁。

**Inputs:** Coin (1 = inserted), Push (1 = attempt to enter).
输入：硬币（1 表示投币）、推门（1 表示尝试进入）。

**Outputs:** Red Light / Green Light (or Lock Signal).
输出：红灯 / 绿灯（或锁信号）。

#### State Transition Table

| Current State |    Input (Coin, Push)    | Next State | Output |
| :------------ | :----------------------: | :--------- | :----- |
| Locked        |   (1, 0) Coin inserted   | Unlocked   | Green  |
| Locked        | (0, 1) Push without coin | Locked     | Red    |
| Unlocked      |        (0, 1) Push       | Locked     | Red    |
| Unlocked      |     (1, 0) Coin again    | Unlocked   | Green  |

该状态转换表描述了旋转门在不同输入下的行为：投币解锁、推门后重新上锁。

---

**State Diagram Description**

```
[Locked] --(Coin/Green)--> [Unlocked]
[Unlocked] --(Push/Red)--> [Locked]
[Locked] --(Push/Red)--> [Locked]
[Unlocked] --(Coin/Green)--> [Unlocked]
```

状态图如上，箭头标注输入/输出。
此示例可设计为Moore机（输出依赖状态）或Mealy机（输出依赖输入与状态）。

---

### 7. Finite State Machine Design Process

**FSM design involves two main steps:**
有限状态机设计主要包括两个步骤：

1. **Capture desired sequential behavior.**
   捕捉目标的时序行为。
2. **Convert that behavior into a sequential circuit.**
   将该行为转换为时序电路实现。

---

#### Step 1: Capture Behavior

**Describe what you want the FSM to do.**
描述希望FSM实现的功能。

**You can capture the behavior using a truth table or equations.**
可以通过真值表或逻辑方程表示行为。

**For each output, specify how it behaves for all combinations of inputs.**
为每个输出定义其在各种输入组合下的表现。

**Then, simplify and derive equations if needed.**
随后进行化简并推导出方程。

---

#### Step 2: Convert to Circuit

**For each output, design a logic circuit corresponding to the equation.**
根据逻辑方程设计输出的逻辑电路。

**Gates can be shared among multiple outputs if convenient.**
若方便，可在多个输出间共享逻辑门。

**This step is similar to designing combinational circuits.**
此步骤与组合逻辑设计方法类似。

---

### 8. Capturing the Behavior

**FSM can be represented graphically by listing states and transitions.**
FSM可通过列出状态及其转换的方式图形化表示。

**Each state is drawn as a circle, labeled with a name (e.g., Locked, Unlocked).**
每个状态用圆圈表示，并标注名称（例如Locked、Unlocked）。

**Transitions are directed arrows showing how one state moves to another.**
状态之间的转换用箭头表示，显示从一个状态到另一个状态的变化。

**Each arrow is labeled with Input/Output to indicate the cause and effect.**
每条箭头上标注输入/输出，用以指示触发条件与结果。

---

#### Example

```
[Locked] --(Coin/Green)--> [Unlocked]
[Unlocked] --(Push/Red)--> [Locked]
```

**This graphical model is called a *state transition diagram*.**
这种图形模型称为*状态转换图（State Transition Diagram）*。

**We can also describe the same behavior using a *state transition table*.**
我们也可以用*状态转换表*描述同样的行为。

---

### 9. Converting FSM to Circuit

**The goal is to translate the state diagram or table into hardware logic.**
目标是将状态图或表转换为实际的硬件逻辑实现。

**This includes:**

1. Encoding each state as binary bits.
2. Defining next-state logic and output logic.
3. Implementing them with flip-flops and gates.
   包括以下三个步骤：
4. 用二进制位对每个状态进行编码。
5. 定义下一状态逻辑与输出逻辑。
6. 用触发器和逻辑门实现电路。

---

#### Example: Laser Controller FSM

**Task:** When a button `b` is pressed, output `x` should be high for 3 clock cycles (each 10 ns).
任务：当按下按钮`b`时，输出`x`应持续为高电平3个时钟周期（每周期10ns）。

**States:**
$$
\text{Off}, \text{On1}, \text{On2}, \text{On3}
$$
状态集合为：Off、On1、On2、On3。

**Outputs:**

* `x = 0` when Off
* `x = 1` when On1, On2, On3
  输出定义如下：
* 当处于Off状态时，x=0
* 当处于On1、On2、On3时，x=1

---

#### Timing Diagram (Behavior Capture)

| Clock Cycle | Input b | Output x | State |
| :---------: | :-----: | :------: | :---: |
|      1      |    0    |     0    |  Off  |
|      2      |    1    |     1    |  On1  |
|      3      |    0    |     1    |  On2  |
|      4      |    0    |     1    |  On3  |
|      5      |    0    |     0    |  Off  |

定时图展示了状态随时钟变化的顺序行为。

---

#### State Transition Diagram

```
Off --(b=1/x=1)--> On1 --(b=0/x=1)--> On2 --(b=0/x=1)--> On3 --(b=0/x=0)--> Off
```

该图表示按下按钮后输出保持3个周期高电平，然后返回初始状态。

---

#### State Encoding

| State |  s₁ |  s₀ |
| :---- | :-: | :-: |
| Off   |  0  |  0  |
| On1   |  0  |  1  |
| On2   |  1  |  0  |
| On3   |  1  |  1  |

每个状态被编码为两个触发器位。

---

#### State Transition Table

|  b  |  s₁ |  s₀ |  n₁ |  n₀ |  x  |
| :-: | :-: | :-: | :-: | :-: | :-: |
|  0  |  0  |  0  |  0  |  0  |  0  |
|  1  |  0  |  0  |  0  |  1  |  1  |
|  0  |  0  |  1  |  1  |  0  |  1  |
|  0  |  1  |  0  |  1  |  1  |  1  |
|  0  |  1  |  1  |  0  |  0  |  0  |

---

#### Logic Equations

Next-state and output equations:

$$
x = s_1 + s_0
$$

$$
n_1 = s_1 \overline{s_0} + s_1 s_0
$$

$$
n_0 = s_1 \overline{s_0} b + \overline{s_1} s_0
$$

输出方程与下一状态方程如上所示。

---

#### Circuit Architecture

**Standard Controller Structure:**

```
Inputs:  b
Outputs: x
State Register: (s₁, s₀)
Combinational Logic: determines (n₁, n₀, x)
Clock: rising edge triggers state update
```

标准控制器结构包括：输入、组合逻辑、状态寄存器与时钟。

---

#### Block Diagram (Textual Representation)

```
+-------------------------+
|        FSM Logic        |
|  +-------------------+  |
|  | Combinational F,G |  |
|  +-------------------+  |
|   ↑           ↓         |
|  Inputs(b)  Outputs(x)  |
+-----------┬-------------+
            |
       +----┴----+
       | Flip-flops |
       | (s₁, s₀)   |
       +-------------+
            ↑ Clock ↑
```

该图描述了FSM控制器的标准结构：组合逻辑 + 状态寄存器 + 时钟同步更新。

---

### 10. Controller Design Process (Summary)

| Step | Description                                                       | 中文说明                |
| :--: | :---------------------------------------------------------------- | :------------------ |
|   1  | Capture FSM behavior (draw state diagram)                         | 捕捉目标行为（绘制状态图）       |
|  2A  | Define architecture: flip-flops + combinational logic             | 定义体系结构：触发器+组合逻辑     |
|  2B  | Encode states as binary                                           | 用二进制为状态编码           |
|  2C  | Create truth table linking (inputs, state) → (next state, output) | 建立输入与状态到输出与下一状态的真值表 |
|  2D  | Derive and simplify logic equations                               | 推导并化简逻辑方程           |
|  2E  | Implement with gates and flip-flops                               | 用逻辑门和触发器实现电路        |

---

### 11. Mealy and Moore Machines (Detailed)

#### Moore Machine

**Output depends only on the current state.**
输出仅依赖当前状态。

$$
\text{Output} = G(\text{State})
$$

**Example:** A counter displaying “even/odd” based only on its state.
例如：一个只根据当前计数值显示“偶/奇”的计数器。

**Advantages:**

* Simpler timing behavior.
* Outputs change only on clock edges.
  优点：
* 时序稳定，输出仅在时钟边沿变化。

---

#### Mealy Machine

**Output depends on both current state and input.**
输出依赖当前状态与输入。

$$
\text{Output} = G(\text{State}, \text{Input})
$$

**Example:** A serial data detector that reacts immediately to input.
例如：一个在检测到特定输入序列时立即输出信号的检测器。

**Advantages:**

* Faster response (output can change within the same clock cycle).
  优点：
* 响应更快，可在同一时钟周期内改变输出。

**Disadvantages:**

* More sensitive to glitches and timing variations.
  缺点：
* 对时序变化更敏感，易产生毛刺。

---

### 12. Example Exercise: Mealy or Moore?

**Given a 2-bit counter circuit with flip-flops and enable inputs (EN).**
给定一个包含触发器与使能输入EN的2位计数器电路。

**Inputs:** Clock, EN, MAX.
输入信号：时钟、使能、最大计数指示。

**Question:** Is the output logic dependent on input or state only?
问题：输出逻辑是否依赖输入？

**Answer:**
If output depends on MAX or EN while changing within a state → Mealy Machine.
若输出在状态内受输入影响而变化 → Mealy机。

If output depends solely on stored state bits → Moore Machine.
若输出仅依赖存储状态位 → Moore机。

---

### 13. Summary

**We have introduced:**
我们已经学习了：

* The concept and structure of Finite State Machines (FSMs).
  有限状态机的概念与结构。

* How to capture sequential behavior using state diagrams and tables.
  如何通过状态图和表格捕捉时序行为。

* The design process: from specification → state encoding → circuit realization.
  设计流程：从功能描述→状态编码→电路实现。

* The distinction between Mealy and Moore machines.
  区分Mealy机与Moore机的关键差异。

* Practical examples including counters, turnstiles, and laser controllers.
  实际案例包括计数器、旋转门与激光控制器。

**FSMs are fundamental building blocks of digital systems, enabling predictable and structured sequential behavior.**
FSM是数字系统的核心结构，能实现可预测、有序的时序控制行为。