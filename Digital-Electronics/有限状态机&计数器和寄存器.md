### **Fundamentals of Digital Electronics â€“ Finite State Machines**
### **æ•°å­—ç”µå­æŠ€æœ¯åŸºç¡€ â€“ æœ‰é™çŠ¶æ€æœº**

---

#### **1. Recap: Foundational Memory Elements (å›é¡¾ï¼šåŸºç¡€å­˜å‚¨å…ƒä»¶)**

*   **The SR Latch (SR é”å­˜å™¨)**:
    *   **Function (åŠŸèƒ½)**: The most basic memory element. It can store a single bit of information (0 or 1).
        æœ€åŸºæœ¬çš„å­˜å‚¨å…ƒä»¶ï¼Œå¯ä»¥å­˜å‚¨ä¸€ä½ä¿¡æ¯ï¼ˆ0 æˆ– 1ï¼‰ã€‚
    *   **"Illegal State" (éæ³•çŠ¶æ€)**: When both inputs S=1 and R=1, both outputs Q and Q' are forced to 0. This state is problematic because:
        å½“è¾“å…¥ S=1 ä¸” R=1 æ—¶ï¼Œä¸¤ä¸ªè¾“å‡º Q å’Œ Q' éƒ½è¢«å¼ºåˆ¶ä¸º 0ã€‚è¿™ä¸ªçŠ¶æ€æ˜¯æœ‰é—®é¢˜çš„ï¼Œå› ä¸ºï¼š
        1.  It violates the fundamental rule that Q should be the inverse of Q'.
            å®ƒè¿åäº† Q åº”è¯¥æ˜¯ Q' åç›¸çš„åŸºæœ¬è§„åˆ™ã€‚
        2.  If S and R then switch to 0 simultaneously, the final state of Q is unpredictable (it can race to either 0 or 1).
            å¦‚æœ S å’Œ R æ¥ç€åŒæ—¶å˜ä¸º 0ï¼ŒQ çš„æœ€ç»ˆçŠ¶æ€æ˜¯ä¸å¯é¢„æµ‹çš„ï¼ˆå®ƒå¯èƒ½ç«äº‰å˜ä¸º 0 æˆ– 1ï¼‰ã€‚
    *   **Logic Table (é€»è¾‘è¡¨)**:
        ```
        S | R | Q(next) | Q'(next) | Comment
        --|---|---------|----------|----------
        0 | 0 | Q       | Q'       | Hold (ä¿æŒ)
        0 | 1 | 0       | 1        | Reset (å¤ä½)
        1 | 0 | 1       | 0        | Set (ç½®ä½)
        1 | 1 | 0       | 0        | Illegal (éæ³•)
        ```

*   **Triggering Methods (è§¦å‘æ–¹å¼)**:
    *   **Latch (é”å­˜å™¨)**: **Level Triggered (ç”µå¹³è§¦å‘)**. The output can change at any time the enable signal (e.g., clock) is at its active level. This property is called "transparency."
        è¾“å‡ºå¯ä»¥åœ¨ä½¿èƒ½ä¿¡å·ï¼ˆä¾‹å¦‚æ—¶é’Ÿï¼‰å¤„äºå…¶æœ‰æ•ˆç”µå¹³çš„ä»»ä½•æ—¶å€™æ”¹å˜ã€‚è¿™ç§ç‰¹æ€§è¢«ç§°ä¸ºâ€œé€æ˜æ€§â€ã€‚
    *   **Flip-Flop (è§¦å‘å™¨)**: **Edge Triggered (è¾¹æ²¿è§¦å‘)**. The output changes *only* at the precise moment of a clock transition (either from low-to-high ğŸ“ˆ for positive-edge, or high-to-low ğŸ“‰ for negative-edge). This ensures all state changes in a system happen in perfect synchronization.
        è¾“å‡º*ä»…*åœ¨æ—¶é’Ÿè½¬æ¢çš„ç²¾ç¡®ç¬é—´æ”¹å˜ï¼ˆå¯¹äºæ­£è¾¹æ²¿æ˜¯ä½åˆ°é«˜ ğŸ“ˆï¼Œå¯¹äºè´Ÿè¾¹æ²¿æ˜¯é«˜åˆ°ä½ ğŸ“‰ï¼‰ã€‚è¿™ç¡®ä¿äº†ç³»ç»Ÿä¸­æ‰€æœ‰çš„çŠ¶æ€å˜åŒ–éƒ½å®Œç¾åŒæ­¥åœ°å‘ç”Ÿã€‚

*   **The D-Type Flip-Flop (D å‹è§¦å‘å™¨)**:
    *   **Purpose (ç›®çš„)**: To eliminate the illegal state of the SR latch. It has only one data input, D.
        æ¶ˆé™¤ SR é”å­˜å™¨çš„éæ³•çŠ¶æ€ã€‚å®ƒåªæœ‰ä¸€ä¸ªæ•°æ®è¾“å…¥ Dã€‚
    *   **Internal Logic (å†…éƒ¨é€»è¾‘)**: It is constructed from an SR flip-flop where the inputs are driven by D: `S = D` and `R = NOT(D)`. This guarantees S and R are never both 1 at the same time.
        å®ƒç”±ä¸€ä¸ª SR è§¦å‘å™¨æ„å»ºï¼Œå…¶è¾“å…¥ç”± D é©±åŠ¨ï¼š`S = D` ä¸” `R = NOT(D)`ã€‚è¿™ä¿è¯äº† S å’Œ R æ°¸è¿œä¸ä¼šåŒæ—¶ä¸º 1ã€‚
    *   **Function (åŠŸèƒ½)**: On the active clock edge, the value at the D input is transferred to the Q output. `Q(next) = D`.
        åœ¨æœ‰æ•ˆçš„æ—¶é’Ÿæ²¿ï¼ŒD è¾“å…¥ç«¯çš„å€¼è¢«ä¼ è¾“åˆ° Q è¾“å‡ºç«¯ã€‚`Q(ä¸‹ä¸€çŠ¶æ€) = D`ã€‚

*   **Asynchronous Inputs (å¼‚æ­¥è¾“å…¥)**:
    *   **PRESET (é¢„ç½®)** & **CLEAR (æ¸…é›¶)**: These inputs override the clock and all other inputs. They are used to force the flip-flop into a known state (PRESET forces Q=1, CLEAR forces Q=0) for initialization.
        è¿™äº›è¾“å…¥ä¼šè¦†ç›–æ—¶é’Ÿå’Œæ‰€æœ‰å…¶ä»–è¾“å…¥ã€‚å®ƒä»¬ç”¨äºå°†è§¦å‘å™¨å¼ºåˆ¶åˆ°ä¸€ä¸ªå·²çŸ¥çš„çŠ¶æ€ï¼ˆPRESET å¼ºåˆ¶ Q=1ï¼ŒCLEAR å¼ºåˆ¶ Q=0ï¼‰ä»¥è¿›è¡Œåˆå§‹åŒ–ã€‚

---

#### **2. Finite State Machine (FSM) Concept (æœ‰é™çŠ¶æ€æœºæ¦‚å¿µ)**

An FSM is a computational model consisting of a finite number of states. It's defined by its list of states, its initial state, and the conditions for each transition.
FSM æ˜¯ä¸€ç§ç”±æœ‰é™æ•°é‡çŠ¶æ€ç»„æˆçš„è®¡ç®—æ¨¡å‹ã€‚å®ƒç”±å…¶çŠ¶æ€åˆ—è¡¨ã€åˆå§‹çŠ¶æ€ä»¥åŠæ¯ä¸ªè½¬æ¢çš„æ¡ä»¶æ¥å®šä¹‰ã€‚

*   **Core Components (æ ¸å¿ƒç»„ä»¶)**:
    *   **States (S)**: A finite set of conditions the machine can be in. (ä¾‹å¦‚: {Locked, Unlocked})ã€‚
        æœºå™¨å¯ä»¥å¤„äºçš„ä¸€ç»„æœ‰é™çš„æ¡ä»¶ã€‚ (e.g., {é”å®š, è§£é”})ã€‚
    *   **Inputs (I)**: The set of signals that influence state transitions. (ä¾‹å¦‚: {Coin, Push})ã€‚
        å½±å“çŠ¶æ€è½¬æ¢çš„ä¿¡å·é›†åˆã€‚ (e.g., {æŠ•å¸, æ¨})ã€‚
    *   **Outputs (O)**: The set of signals generated by the machine. (ä¾‹å¦‚: {Green Arrow, Red Cross})ã€‚
        ç”±æœºå™¨ç”Ÿæˆçš„ä¿¡å·é›†åˆã€‚ (e.g., {ç»¿ç®­å¤´, çº¢å‰})ã€‚
    *   **Transition Function (Î´)**: Determines the next state based on the current state and inputs.
        æ ¹æ®å½“å‰çŠ¶æ€å’Œè¾“å…¥æ¥å†³å®šä¸‹ä¸€ä¸ªçŠ¶æ€ã€‚
        `Next State = Î´(Current State, Inputs)`
    *   **Output Function (Î»)**: Determines the outputs. This function defines the FSM type.
        å†³å®šè¾“å‡ºã€‚è¿™ä¸ªå‡½æ•°å®šä¹‰äº† FSM çš„ç±»å‹ã€‚

---

#### **3. Types of FSM: Mealy vs. Moore Machines (FSM çš„ç±»å‹ï¼šMealy æœºä¸ Moore æœº)**

This is a critical distinction based on the output function Î».
è¿™æ˜¯ä¸€ä¸ªåŸºäºè¾“å‡ºå‡½æ•° Î» çš„å…³é”®åŒºåˆ«ã€‚

| Feature (ç‰¹å¾) | Moore Machine (Moore æœº) | Mealy Machine (Mealy æœº) |
| :--- | :--- | :--- |
| **Output Logic (è¾“å‡ºé€»è¾‘)** | Output depends **only** on the **current state**. | Output depends on **both** the **current state AND current inputs**. |
| **Output Formula (è¾“å‡ºå…¬å¼)** | `Output = Î»(Current State)` | `Output = Î»(Current State, Inputs)` |
| **State Diagram (çŠ¶æ€å›¾)** | Output is written **inside the state circle**. (è¾“å‡ºå†™åœ¨**çŠ¶æ€åœˆå†…éƒ¨**)<br> `(State / Output)` | Output is written **on the transition arc**. (è¾“å‡ºå†™åœ¨**è½¬æ¢å¼§ä¸Š**)<br> `Input / Output` |
| **Timing (æ—¶åº)** | Outputs change synchronously with state transitions (after a clock edge). This may introduce a 1-cycle delay. (è¾“å‡ºä¸çŠ¶æ€è½¬æ¢åŒæ­¥æ”¹å˜ï¼ˆåœ¨æ—¶é’Ÿæ²¿ä¹‹åï¼‰ã€‚è¿™å¯èƒ½ä¼šå¼•å…¥ä¸€ä¸ªå‘¨æœŸçš„å»¶è¿Ÿã€‚) | Outputs can change immediately and asynchronously in response to input changes. This offers a faster response but can cause glitches. (è¾“å‡ºå¯ä»¥å“åº”è¾“å…¥çš„å˜åŒ–è€Œç«‹å³å¼‚æ­¥æ”¹å˜ã€‚è¿™æä¾›äº†æ›´å¿«çš„å“åº”ï¼Œä½†å¯èƒ½å¯¼è‡´æ¯›åˆºã€‚) |
| **Example Diagram (å›¾ä¾‹)** | <pre> (S0 / 0) ---Input 1---> (S1 / 1) </pre> | <pre> S0 ---Input 1 / Output 1---> S1 </pre> |

---

#### **4. FSM Design Process: From Concept to Circuit (FSM è®¾è®¡æµç¨‹ï¼šä»æ¦‚å¿µåˆ°ç”µè·¯)**

**Step 1: Capture Behaviour (æ•è·è¡Œä¸º)**
1.  **State Diagram (çŠ¶æ€å›¾)**: Visualize the states and transitions. For the laser example:
    å¯è§†åŒ–çŠ¶æ€å’Œè½¬æ¢ã€‚ä»¥æ¿€å…‰å™¨ä¸ºä¾‹ï¼š
    ```
         +------- b=0 --------+
         |                    |
    ---> ( Off/x=0 ) --b=1--> ( On1/x=1 ) --+--> ( On2/x=1 ) --+--> ( On3/x=1 ) --+
                                            |                  |                  |
                                            +------------------+------------------+
    ```
2.  **State Transition Table (çŠ¶æ€è½¬æ¢è¡¨)**: Formalize the diagram.
    å°†å›¾è¡¨å½¢å¼åŒ–ã€‚

| Present State (å½“å‰çŠ¶æ€) | Input b (è¾“å…¥b) | Next State (ä¸‹ä¸€çŠ¶æ€) | Output x (è¾“å‡ºx) |
| :--- | :--- | :--- | :--- |
| Off | 0 | Off | 0 |
| Off | 1 | On1 | 0 |
| On1 | X | On2 | 1 |
| On2 | X | On3 | 1 |
| On3 | X | Off | 1 |

**Step 2: Convert to Circuit (è½¬æ¢ä¸ºç”µè·¯)**
1.  **State Encoding (çŠ¶æ€ç¼–ç )**: Assign unique binary codes. The number of bits needed `n` is `n = âŒˆlogâ‚‚(number of states)âŒ‰`. For 4 states, we need `âŒˆlogâ‚‚(4)âŒ‰ = 2` bits.
    åˆ†é…å”¯ä¸€çš„äºŒè¿›åˆ¶ä»£ç ã€‚æ‰€éœ€ä½æ•° `n` ä¸º `n = âŒˆlogâ‚‚(çŠ¶æ€æ•°)âŒ‰`ã€‚å¯¹äº 4 ä¸ªçŠ¶æ€ï¼Œæˆ‘ä»¬éœ€è¦ `âŒˆlogâ‚‚(4)âŒ‰ = 2` ä½ã€‚
    *   Off: `s1s0 = 00`
    *   On1: `s1s0 = 01`
    *   On2: `s1s0 = 10`
    *   On3: `s1s0 = 11`

2.  **Derive Truth Table (æ¨å¯¼çœŸå€¼è¡¨)**: Combine the transition table and encoding. `n1n0` are the next state bits.
    ç»“åˆè½¬æ¢è¡¨å’Œç¼–ç ã€‚`n1n0` æ˜¯ä¸‹ä¸€çŠ¶æ€ä½ã€‚

| s1 | s0 | b | n1 | n0 | x |
|:--:|:--:|:-:|:--:|:--:|:-:|
| 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 0 | 1 | 0 |
| 0 | 1 | X | 1 | 0 | 1 |
| 1 | 0 | X | 1 | 1 | 1 |
| 1 | 1 | X | 0 | 0 | 1 |

3.  **Find Boolean Equations (æ±‚è§£å¸ƒå°”æ–¹ç¨‹)**: From the truth table, derive logic for each output and next-state bit. (From slide 24)
    ä»çœŸå€¼è¡¨ä¸­ï¼Œä¸ºæ¯ä¸ªè¾“å‡ºå’Œä¸‹ä¸€çŠ¶æ€ä½æ¨å¯¼é€»è¾‘ã€‚ï¼ˆæ¥è‡ªå¹»ç¯ç‰‡ 24ï¼‰
    *   `x = s1 + s0`
    *   `n1 = s1's0 + s1s0' = s1 âŠ• s0` (XOR)
    *   `n0 = s1's0'b + s1s0'`

4.  **Implement Circuit Architecture (å®ç°ç”µè·¯æ¶æ„)**:
    *   **State Register (çŠ¶æ€å¯„å­˜å™¨)**: 2 D-type flip-flops to store the current state bits `s1` and `s0`.
        2 ä¸ª D å‹è§¦å‘å™¨ç”¨äºå­˜å‚¨å½“å‰çŠ¶æ€ä½ `s1` å’Œ `s0`ã€‚
    *   **Combinational Logic (ç»„åˆé€»è¾‘)**: Gates to implement the equations for `x`, `n1`, and `n0`.
        å®ç° `x`, `n1`, å’Œ `n0` æ–¹ç¨‹çš„é€»è¾‘é—¨ã€‚

    **Conceptual Diagram (æ¦‚å¿µå›¾)**:
    ```
                   +-----------------------+
    System Inputs --->|  Combinational Logic  | ---> System Outputs (x)
         (b)        |       (Gates)         |
                    +-----------------------+
                        ^            |
                        | Next State |
                        | (n1, n0)   |
          +-------------+------------+
          |             |
          v             |
    +-----------+   Current State
    | D FF (s1) |-----> (s1)
    | D FF (s0) |-----> (s0)
    +-----------+
         ^
         |
        CLK
    ```

---

### **Counters and Registers (ç¬¬ 9 è®²ï¼šè®¡æ•°å™¨å’Œå¯„å­˜å™¨)**

---

#### **1. Types of Counters (è®¡æ•°å™¨çš„ç±»å‹)**

**Asynchronous (Ripple) Counter (å¼‚æ­¥ï¼ˆè„‰åŠ¨ï¼‰è®¡æ•°å™¨)**
*   **Structure (ç»“æ„)**: No common clock. The output of one flip-flop clocks the next.
    æ²¡æœ‰å…±åŒæ—¶é’Ÿã€‚ä¸€ä¸ªè§¦å‘å™¨çš„è¾“å‡ºä½œä¸ºä¸‹ä¸€ä¸ªè§¦å‘å™¨çš„æ—¶é’Ÿã€‚
    `CLK â¡ï¸ [FF0] --Q0--> CLK_in [FF1] --Q1--> CLK_in [FF2] ...`
*   **Propagation Delay (ä¼ æ’­å»¶è¿Ÿ)**: The main disadvantage. The total delay is the sum of individual delays, limiting the maximum frequency.
    ä¸»è¦ç¼ºç‚¹ã€‚æ€»å»¶è¿Ÿæ˜¯å•ä¸ªå»¶è¿Ÿçš„æ€»å’Œï¼Œè¿™é™åˆ¶äº†æœ€å¤§é¢‘ç‡ã€‚
    `t_total_delay = N Ã— t_pd`
    (where `N` = number of flip-flops, `t_pd` = propagation delay of one flip-flop)
    ï¼ˆå…¶ä¸­ `N` = è§¦å‘å™¨æ•°é‡, `t_pd` = å•ä¸ªè§¦å‘å™¨çš„ä¼ æ’­å»¶è¿Ÿï¼‰

**Synchronous Counter (åŒæ­¥è®¡æ•°å™¨)**
*   **Structure (ç»“æ„)**: All flip-flops share a common clock. Additional logic determines which flip-flops toggle.
    æ‰€æœ‰è§¦å‘å™¨å…±äº«ä¸€ä¸ªå…±åŒæ—¶é’Ÿã€‚é™„åŠ çš„é€»è¾‘å†³å®šå“ªäº›è§¦å‘å™¨ç¿»è½¬ã€‚
*   **Logic Example (for a 3-bit binary up-counter using J-K FFs) (é€»è¾‘ç¤ºä¾‹ï¼ˆä½¿ç”¨ J-K è§¦å‘å™¨çš„ 3 ä½äºŒè¿›åˆ¶åŠ æ³•è®¡æ•°å™¨ï¼‰)**:
    *   FF0 toggles on every clock pulse: `Jâ‚€ = Kâ‚€ = 1`
    *   FF1 toggles only when Q0 is 1: `Jâ‚ = Kâ‚ = Qâ‚€`
    *   FF2 toggles only when Q0 and Q1 are both 1: `Jâ‚‚ = Kâ‚‚ = Qâ‚€ â‹… Qâ‚`
*   **Advantage (ä¼˜ç‚¹)**: No cumulative delay. All bits change simultaneously, allowing for much higher speeds.
    æ²¡æœ‰ç´¯ç§¯å»¶è¿Ÿã€‚æ‰€æœ‰ä½åŒæ—¶æ”¹å˜ï¼Œå…è®¸æ›´é«˜çš„é€Ÿåº¦ã€‚

---

#### **2. Applications of Counters (è®¡æ•°å™¨çš„åº”ç”¨)**

**1. Frequency Division (åˆ†é¢‘)**
*   **By a Power of 2 (2 çš„å¹‚æ¬¡åˆ†é¢‘)**: The output of the nth flip-flop in a ripple counter divides the clock by 2â¿.
    è„‰åŠ¨è®¡æ•°å™¨ä¸­ç¬¬ n ä¸ªè§¦å‘å™¨çš„è¾“å‡ºå°†æ—¶é’Ÿé¢‘ç‡é™¤ä»¥ 2â¿ã€‚
    `f_out_n = f_clk / 2^(n+1)` (for the nth FF, starting at n=0)

*   **By an Arbitrary Number N (MOD-N Counter) (ä»»æ„æ•° N åˆ†é¢‘ï¼ˆMOD-N è®¡æ•°å™¨ï¼‰)**:
    *   **Using a Down-Counter (ä½¿ç”¨å‡æ³•è®¡æ•°å™¨)**: To divide by N, create a cycle of N states.
        1.  Parallel load the value `N-1` into the counter.
            å°†å€¼ `N-1` å¹¶è¡ŒåŠ è½½åˆ°è®¡æ•°å™¨ä¸­ã€‚
        2.  Let the counter count down.
            è®©è®¡æ•°å™¨å‘ä¸‹è®¡æ•°ã€‚
        3.  When the counter reaches zero, the Terminal Count (`tc`) output goes high.
            å½“è®¡æ•°å™¨è¾¾åˆ°é›¶æ—¶ï¼Œç»ˆç«¯è®¡æ•° (`tc`) è¾“å‡ºå˜ä¸ºé«˜ç”µå¹³ã€‚
        4.  Use the `tc` signal to trigger the parallel load (`ld`) on the next clock edge, reloading `N-1`.
            ä½¿ç”¨ `tc` ä¿¡å·åœ¨ä¸‹ä¸€ä¸ªæ—¶é’Ÿæ²¿è§¦å‘å¹¶è¡ŒåŠ è½½ (`ld`)ï¼Œé‡æ–°åŠ è½½ `N-1`ã€‚
        **Example (Divide by 9)**: Load `9-1=8` (1000). The sequence is 8, 7, 6, 5, 4, 3, 2, 1, 0 (9 states). `tc` pulses every 9 clock cycles.
        **ç¤ºä¾‹ï¼ˆé™¤ä»¥ 9ï¼‰**: åŠ è½½ `9-1=8` (1000)ã€‚åºåˆ—ä¸º 8, 7, 6, 5, 4, 3, 2, 1, 0 (9 ä¸ªçŠ¶æ€)ã€‚`tc` æ¯ 9 ä¸ªæ—¶é’Ÿå‘¨æœŸäº§ç”Ÿä¸€ä¸ªè„‰å†²ã€‚

    *   **Using an Up-Counter (ä½¿ç”¨åŠ æ³•è®¡æ•°å™¨)**: To divide by N.
        1.  Let the counter count up from 0.
            è®©è®¡æ•°å™¨ä» 0 å¼€å§‹å‘ä¸Šè®¡æ•°ã€‚
        2.  Use external logic (e.g., an AND gate) to detect when the count reaches `N-1`.
            ä½¿ç”¨å¤–éƒ¨é€»è¾‘ï¼ˆä¾‹å¦‚ï¼Œä¸é—¨ï¼‰æ¥æ£€æµ‹è®¡æ•°ä½•æ—¶è¾¾åˆ° `N-1`ã€‚
        3.  Use this detection signal to trigger the synchronous clear (`clr`) on the *next* clock pulse.
            ä½¿ç”¨è¿™ä¸ªæ£€æµ‹ä¿¡å·åœ¨*ä¸‹ä¸€ä¸ª*æ—¶é’Ÿè„‰å†²æ—¶è§¦å‘åŒæ­¥æ¸…é›¶ (`clr`)ã€‚
        **Example (Divide by 60)**: Detect count `59` (111011). This signal clears the counter on the 60th clock pulse, returning it to 0. The detection signal itself is the 1 Hz output.
        **ç¤ºä¾‹ï¼ˆé™¤ä»¥ 60ï¼‰**: æ£€æµ‹è®¡æ•°å€¼ `59` (111011)ã€‚è¯¥ä¿¡å·åœ¨ç¬¬ 60 ä¸ªæ—¶é’Ÿè„‰å†²æ—¶æ¸…é™¤è®¡æ•°å™¨ï¼Œä½¿å…¶è¿”å› 0ã€‚è¯¥æ£€æµ‹ä¿¡å·æœ¬èº«å°±æ˜¯ 1 Hz çš„è¾“å‡ºã€‚

**2. Counter as a Timer (è®¡æ•°å™¨ä½œä¸ºè®¡æ—¶å™¨)**
*   **Principle (åŸç†)**: Measure time by counting clock pulses of a known period.
    é€šè¿‡è®¡ç®—å·²çŸ¥å‘¨æœŸçš„æ—¶é’Ÿè„‰å†²æ•°æ¥æµ‹é‡æ—¶é—´ã€‚
*   **Formula (å…¬å¼)**:
    `Time = C Ã— T_clk = C / f_clk`
    (where `C` = final count, `T_clk` = clock period, `f_clk` = clock frequency)
    ï¼ˆå…¶ä¸­ `C` = æœ€ç»ˆè®¡æ•°å€¼, `T_clk` = æ—¶é’Ÿå‘¨æœŸ, `f_clk` = æ—¶é’Ÿé¢‘ç‡ï¼‰
*   **Speed Measurement Example (é€Ÿåº¦æµ‹é‡ç¤ºä¾‹)**:
    1.  **Inputs (è¾“å…¥)**:
        *   Distance between sensors `d` (meters).
        *   Clock frequency `f_clk` (Hz).
    2.  **Process (è¿‡ç¨‹)**:
        *   Start counter when car passes sensor 'a'.
            å½“æ±½è½¦é€šè¿‡ä¼ æ„Ÿå™¨ 'a' æ—¶å¯åŠ¨è®¡æ•°å™¨ã€‚
        *   Stop counter when car passes sensor 'b'.
            å½“æ±½è½¦é€šè¿‡ä¼ æ„Ÿå™¨ 'b' æ—¶åœæ­¢è®¡æ•°å™¨ã€‚
        *   Read the final count `C`.
            è¯»å–æœ€ç»ˆè®¡æ•°å€¼ `C`ã€‚
    3.  **Calculation (è®¡ç®—)**:
        *   Time taken: `t = C / f_clk` (seconds)
        *   Speed: `v = d / t = d / (C / f_clk) = (d Ã— f_clk) / C` (meters/sec)

---

## ğŸ§  Lecture 8 â€“ Finite State Machines

---

### 1. Recap

**The SR Latch â€“ basic memory element â€“ 1 illegal state.**
SRé”å­˜å™¨â€”â€”åŸºæœ¬å­˜å‚¨å…ƒä»¶â€”â€”å­˜åœ¨ä¸€ä¸ªéæ³•çŠ¶æ€ã€‚

**SR Latch with Enable input.**
å¸¦æœ‰ä½¿èƒ½è¾“å…¥çš„SRé”å­˜å™¨ã€‚

**Latch is LEVEL triggered; a Flip-flop is EDGE triggered.**
é”å­˜å™¨æ˜¯ç”µå¹³è§¦å‘çš„ï¼›è§¦å‘å™¨æ˜¯è¾¹æ²¿è§¦å‘çš„ã€‚

**D-type Flip-flop is built from RESET being the complement of SET â€“ i.e., no possibility of Set and Reset at the same time.**
Då‹è§¦å‘å™¨ç”±äº’è¡¥çš„SETä¸RESETä¿¡å·æ„æˆâ€”â€”å³ä¸ä¼šåŒæ—¶å‡ºç°ç½®ä½å’Œå¤ä½ã€‚

**Can add PRESET and CLEAR that are asynchronous â€“ they do not depend on the clock.**
å¯ä»¥åŠ å…¥å¼‚æ­¥çš„é¢„ç½®ï¼ˆPRESETï¼‰å’Œæ¸…é›¶ï¼ˆCLEARï¼‰è¾“å…¥â€”â€”å®ƒä»¬ä¸ä¾èµ–æ—¶é’Ÿä¿¡å·ã€‚

---

### 2. Objectives

**Understand the concept of state machines.**
ç†è§£æœ‰é™çŠ¶æ€æœºï¼ˆFSMï¼‰çš„æ¦‚å¿µã€‚

**Design and analyze the behavior of state machines.**
å­¦ä¹ æœ‰é™çŠ¶æ€æœºçš„è®¾è®¡ä¸è¡Œä¸ºåˆ†æã€‚

**Be familiar with different types of state machines (Mealy and Moore).**
ç†Ÿæ‚‰ä¸¤ç§çŠ¶æ€æœºç±»å‹ï¼šMealyæœºä¸Mooreæœºã€‚

---

### 3. Finite State Machine Concept

**A finite state machine (FSM) generates a change in response to a clock pulse based on the current state and input conditions.**
æœ‰é™çŠ¶æ€æœºåœ¨æ¯ä¸ªæ—¶é’Ÿè„‰å†²ä¸‹ï¼Œæ ¹æ®å½“å‰çŠ¶æ€å’Œè¾“å…¥æ¡ä»¶äº§ç”ŸçŠ¶æ€å˜åŒ–ã€‚

**Example â€“ a counter.**
ä¾‹å­â€”â€”è®¡æ•°å™¨ã€‚

**No inputs; transitions occur in response to clock; the behavior is cyclic.**
æ— å¤–éƒ¨è¾“å…¥ï¼Œä»…éšæ—¶é’Ÿå˜åŒ–è€Œå¾ªç¯è®¡æ•°ã€‚

#### 3-bit Counter State Table

| Current State (Aâ‚‚ Aâ‚ Aâ‚€) | Next State (Yâ‚‚ Yâ‚ Yâ‚€) |
| :----------------------: | :-------------------: |
|            000           |          001          |
|            001           |          010          |
|            010           |          011          |
|            011           |          100          |
|            100           |          101          |
|            101           |          110          |
|            110           |          111          |
|            111           |          000          |

å½“å‰çŠ¶æ€åˆ°ä¸‹ä¸€çŠ¶æ€çš„è½¬æ¢è¡¨å¦‚ä¸Šã€‚
è¿™ä½“ç°äº†ä¸€ä¸ªä¸‰ä½äºŒè¿›åˆ¶è®¡æ•°å™¨çš„å¾ªç¯è®¡æ•°è§„å¾‹ã€‚

---

#### Logic Equations for Next State

$$
Y_0 = \overline{A_0} \
Y_1 = A_1 \oplus A_0 \
Y_2 = A_2A_1 + A_2A_0 + A_2A_1A_0
$$

**These equations define how the next state depends on the current state.**
è¿™äº›å…¬å¼å®šä¹‰äº†ä¸‹ä¸€çŠ¶æ€å¦‚ä½•ç”±å½“å‰çŠ¶æ€ç¡®å®šã€‚

**Combinational logic computes Yâ‚‚ Yâ‚ Yâ‚€ from Aâ‚‚ Aâ‚ Aâ‚€.**
ç»„åˆé€»è¾‘ç”µè·¯æ ¹æ®å½“å‰çŠ¶æ€è®¡ç®—ä¸‹ä¸€çŠ¶æ€ã€‚

**Sequential logic (stored in flip-flops) updates Aâ‚‚ Aâ‚ Aâ‚€ on each clock pulse.**
æ—¶åºé€»è¾‘ï¼ˆè§¦å‘å™¨å­˜å‚¨ï¼‰åœ¨æ¯ä¸ªæ—¶é’Ÿè„‰å†²æ—¶æ›´æ–°çŠ¶æ€ã€‚

---

### 4. Finite State Machine Definitions

**Inputs â€“ any stimuli from the external world (often switches or binary sensors).**
è¾“å…¥â€”â€”æ¥è‡ªå¤–ç•Œçš„åˆºæ¿€ä¿¡å·ï¼Œé€šå¸¸æ˜¯å¼€å…³æˆ–äºŒè¿›åˆ¶ä¼ æ„Ÿå™¨ã€‚

**FSM inputs are usually single-bit signals.**
FSMçš„è¾“å…¥é€šå¸¸ä¸ºå•æ¯”ç‰¹ä¿¡å·ã€‚

**State â€“ describes the current condition of the machine; it is determined by history.**
çŠ¶æ€â€”â€”æè¿°ç³»ç»Ÿå½“å‰çš„æ¡ä»¶ï¼Œç”±ç³»ç»Ÿçš„å†å²å†³å®šã€‚

**Outputs â€“ signals linked to the state; may depend on state only (Moore) or on state and input (Mealy).**
è¾“å‡ºâ€”â€”ä¸çŠ¶æ€ç›¸å…³çš„ä¿¡å·ï¼Œå¯èƒ½ä»…å–å†³äºçŠ¶æ€ï¼ˆMooreæœºï¼‰ï¼Œæˆ–åŒæ—¶å–å†³äºçŠ¶æ€ä¸è¾“å…¥ï¼ˆMealyæœºï¼‰ã€‚

---

### 5. Mealy and Moore Machines (Overview)

**Moore Machine â€“ output depends only on the current state.**
Mooreæœºâ€”â€”è¾“å‡ºä»…ä¾èµ–å½“å‰çŠ¶æ€ã€‚

**Mealy Machine â€“ output depends on both state and input.**
Mealyæœºâ€”â€”è¾“å‡ºä¾èµ–äºçŠ¶æ€å’Œè¾“å…¥ã€‚

**Memory elements (flip-flops) store the state bits and update on clock edges.**
å­˜å‚¨å…ƒä»¶ï¼ˆè§¦å‘å™¨ï¼‰å­˜å‚¨çŠ¶æ€ä½ï¼Œå¹¶åœ¨æ—¶é’Ÿè¾¹æ²¿æ›´æ–°ã€‚

---

### 6. Turnstile Example (Practical FSM)

**A turnstile controls access to a subway.**
æ—‹è½¬é—¨ç”¨äºåœ°é“å‡ºå…¥å£æ§åˆ¶ã€‚

**Initially locked; inserting a coin unlocks it; pushing through locks it again.**
åˆå§‹ä¸ºé”å®šçŠ¶æ€ï¼›æŠ•å…¥ç¡¬å¸åè§£é”ï¼›é€šè¿‡åå†æ¬¡é”å®šã€‚

**Two states:** Locked / Unlocked.
ä¸¤ä¸ªçŠ¶æ€ï¼šé”å®š / è§£é”ã€‚

**Inputs:** Coin (1 = inserted), Push (1 = attempt to enter).
è¾“å…¥ï¼šç¡¬å¸ï¼ˆ1 è¡¨ç¤ºæŠ•å¸ï¼‰ã€æ¨é—¨ï¼ˆ1 è¡¨ç¤ºå°è¯•è¿›å…¥ï¼‰ã€‚

**Outputs:** Red Light / Green Light (or Lock Signal).
è¾“å‡ºï¼šçº¢ç¯ / ç»¿ç¯ï¼ˆæˆ–é”ä¿¡å·ï¼‰ã€‚

#### State Transition Table

| Current State |    Input (Coin, Push)    | Next State | Output |
| :------------ | :----------------------: | :--------- | :----- |
| Locked        |   (1, 0) Coin inserted   | Unlocked   | Green  |
| Locked        | (0, 1) Push without coin | Locked     | Red    |
| Unlocked      |        (0, 1) Push       | Locked     | Red    |
| Unlocked      |     (1, 0) Coin again    | Unlocked   | Green  |

è¯¥çŠ¶æ€è½¬æ¢è¡¨æè¿°äº†æ—‹è½¬é—¨åœ¨ä¸åŒè¾“å…¥ä¸‹çš„è¡Œä¸ºï¼šæŠ•å¸è§£é”ã€æ¨é—¨åé‡æ–°ä¸Šé”ã€‚

---

**State Diagram Description**

```
[Locked] --(Coin/Green)--> [Unlocked]
[Unlocked] --(Push/Red)--> [Locked]
[Locked] --(Push/Red)--> [Locked]
[Unlocked] --(Coin/Green)--> [Unlocked]
```

çŠ¶æ€å›¾å¦‚ä¸Šï¼Œç®­å¤´æ ‡æ³¨è¾“å…¥/è¾“å‡ºã€‚
æ­¤ç¤ºä¾‹å¯è®¾è®¡ä¸ºMooreæœºï¼ˆè¾“å‡ºä¾èµ–çŠ¶æ€ï¼‰æˆ–Mealyæœºï¼ˆè¾“å‡ºä¾èµ–è¾“å…¥ä¸çŠ¶æ€ï¼‰ã€‚

---

### 7. Finite State Machine Design Process

**FSM design involves two main steps:**
æœ‰é™çŠ¶æ€æœºè®¾è®¡ä¸»è¦åŒ…æ‹¬ä¸¤ä¸ªæ­¥éª¤ï¼š

1. **Capture desired sequential behavior.**
   æ•æ‰ç›®æ ‡çš„æ—¶åºè¡Œä¸ºã€‚
2. **Convert that behavior into a sequential circuit.**
   å°†è¯¥è¡Œä¸ºè½¬æ¢ä¸ºæ—¶åºç”µè·¯å®ç°ã€‚

---

#### Step 1: Capture Behavior

**Describe what you want the FSM to do.**
æè¿°å¸Œæœ›FSMå®ç°çš„åŠŸèƒ½ã€‚

**You can capture the behavior using a truth table or equations.**
å¯ä»¥é€šè¿‡çœŸå€¼è¡¨æˆ–é€»è¾‘æ–¹ç¨‹è¡¨ç¤ºè¡Œä¸ºã€‚

**For each output, specify how it behaves for all combinations of inputs.**
ä¸ºæ¯ä¸ªè¾“å‡ºå®šä¹‰å…¶åœ¨å„ç§è¾“å…¥ç»„åˆä¸‹çš„è¡¨ç°ã€‚

**Then, simplify and derive equations if needed.**
éšåè¿›è¡ŒåŒ–ç®€å¹¶æ¨å¯¼å‡ºæ–¹ç¨‹ã€‚

---

#### Step 2: Convert to Circuit

**For each output, design a logic circuit corresponding to the equation.**
æ ¹æ®é€»è¾‘æ–¹ç¨‹è®¾è®¡è¾“å‡ºçš„é€»è¾‘ç”µè·¯ã€‚

**Gates can be shared among multiple outputs if convenient.**
è‹¥æ–¹ä¾¿ï¼Œå¯åœ¨å¤šä¸ªè¾“å‡ºé—´å…±äº«é€»è¾‘é—¨ã€‚

**This step is similar to designing combinational circuits.**
æ­¤æ­¥éª¤ä¸ç»„åˆé€»è¾‘è®¾è®¡æ–¹æ³•ç±»ä¼¼ã€‚

---

### 8. Capturing the Behavior

**FSM can be represented graphically by listing states and transitions.**
FSMå¯é€šè¿‡åˆ—å‡ºçŠ¶æ€åŠå…¶è½¬æ¢çš„æ–¹å¼å›¾å½¢åŒ–è¡¨ç¤ºã€‚

**Each state is drawn as a circle, labeled with a name (e.g., Locked, Unlocked).**
æ¯ä¸ªçŠ¶æ€ç”¨åœ†åœˆè¡¨ç¤ºï¼Œå¹¶æ ‡æ³¨åç§°ï¼ˆä¾‹å¦‚Lockedã€Unlockedï¼‰ã€‚

**Transitions are directed arrows showing how one state moves to another.**
çŠ¶æ€ä¹‹é—´çš„è½¬æ¢ç”¨ç®­å¤´è¡¨ç¤ºï¼Œæ˜¾ç¤ºä»ä¸€ä¸ªçŠ¶æ€åˆ°å¦ä¸€ä¸ªçŠ¶æ€çš„å˜åŒ–ã€‚

**Each arrow is labeled with Input/Output to indicate the cause and effect.**
æ¯æ¡ç®­å¤´ä¸Šæ ‡æ³¨è¾“å…¥/è¾“å‡ºï¼Œç”¨ä»¥æŒ‡ç¤ºè§¦å‘æ¡ä»¶ä¸ç»“æœã€‚

---

#### Example

```
[Locked] --(Coin/Green)--> [Unlocked]
[Unlocked] --(Push/Red)--> [Locked]
```

**This graphical model is called a *state transition diagram*.**
è¿™ç§å›¾å½¢æ¨¡å‹ç§°ä¸º*çŠ¶æ€è½¬æ¢å›¾ï¼ˆState Transition Diagramï¼‰*ã€‚

**We can also describe the same behavior using a *state transition table*.**
æˆ‘ä»¬ä¹Ÿå¯ä»¥ç”¨*çŠ¶æ€è½¬æ¢è¡¨*æè¿°åŒæ ·çš„è¡Œä¸ºã€‚

---

### 9. Converting FSM to Circuit

**The goal is to translate the state diagram or table into hardware logic.**
ç›®æ ‡æ˜¯å°†çŠ¶æ€å›¾æˆ–è¡¨è½¬æ¢ä¸ºå®é™…çš„ç¡¬ä»¶é€»è¾‘å®ç°ã€‚

**This includes:**

1. Encoding each state as binary bits.
2. Defining next-state logic and output logic.
3. Implementing them with flip-flops and gates.
   åŒ…æ‹¬ä»¥ä¸‹ä¸‰ä¸ªæ­¥éª¤ï¼š
4. ç”¨äºŒè¿›åˆ¶ä½å¯¹æ¯ä¸ªçŠ¶æ€è¿›è¡Œç¼–ç ã€‚
5. å®šä¹‰ä¸‹ä¸€çŠ¶æ€é€»è¾‘ä¸è¾“å‡ºé€»è¾‘ã€‚
6. ç”¨è§¦å‘å™¨å’Œé€»è¾‘é—¨å®ç°ç”µè·¯ã€‚

---

#### Example: Laser Controller FSM

**Task:** When a button `b` is pressed, output `x` should be high for 3 clock cycles (each 10 ns).
ä»»åŠ¡ï¼šå½“æŒ‰ä¸‹æŒ‰é’®`b`æ—¶ï¼Œè¾“å‡º`x`åº”æŒç»­ä¸ºé«˜ç”µå¹³3ä¸ªæ—¶é’Ÿå‘¨æœŸï¼ˆæ¯å‘¨æœŸ10nsï¼‰ã€‚

**States:**
$$
\text{Off}, \text{On1}, \text{On2}, \text{On3}
$$
çŠ¶æ€é›†åˆä¸ºï¼šOffã€On1ã€On2ã€On3ã€‚

**Outputs:**

* `x = 0` when Off
* `x = 1` when On1, On2, On3
  è¾“å‡ºå®šä¹‰å¦‚ä¸‹ï¼š
* å½“å¤„äºOffçŠ¶æ€æ—¶ï¼Œx=0
* å½“å¤„äºOn1ã€On2ã€On3æ—¶ï¼Œx=1

---

#### Timing Diagram (Behavior Capture)

| Clock Cycle | Input b | Output x | State |
| :---------: | :-----: | :------: | :---: |
|      1      |    0    |     0    |  Off  |
|      2      |    1    |     1    |  On1  |
|      3      |    0    |     1    |  On2  |
|      4      |    0    |     1    |  On3  |
|      5      |    0    |     0    |  Off  |

å®šæ—¶å›¾å±•ç¤ºäº†çŠ¶æ€éšæ—¶é’Ÿå˜åŒ–çš„é¡ºåºè¡Œä¸ºã€‚

---

#### State Transition Diagram

```
Off --(b=1/x=1)--> On1 --(b=0/x=1)--> On2 --(b=0/x=1)--> On3 --(b=0/x=0)--> Off
```

è¯¥å›¾è¡¨ç¤ºæŒ‰ä¸‹æŒ‰é’®åè¾“å‡ºä¿æŒ3ä¸ªå‘¨æœŸé«˜ç”µå¹³ï¼Œç„¶åè¿”å›åˆå§‹çŠ¶æ€ã€‚

---

#### State Encoding

| State |  sâ‚ |  sâ‚€ |
| :---- | :-: | :-: |
| Off   |  0  |  0  |
| On1   |  0  |  1  |
| On2   |  1  |  0  |
| On3   |  1  |  1  |

æ¯ä¸ªçŠ¶æ€è¢«ç¼–ç ä¸ºä¸¤ä¸ªè§¦å‘å™¨ä½ã€‚

---

#### State Transition Table

|  b  |  sâ‚ |  sâ‚€ |  nâ‚ |  nâ‚€ |  x  |
| :-: | :-: | :-: | :-: | :-: | :-: |
|  0  |  0  |  0  |  0  |  0  |  0  |
|  1  |  0  |  0  |  0  |  1  |  1  |
|  0  |  0  |  1  |  1  |  0  |  1  |
|  0  |  1  |  0  |  1  |  1  |  1  |
|  0  |  1  |  1  |  0  |  0  |  0  |

---

#### Logic Equations

Next-state and output equations:

$$
x = s_1 + s_0
$$

$$
n_1 = s_1 \overline{s_0} + s_1 s_0
$$

$$
n_0 = s_1 \overline{s_0} b + \overline{s_1} s_0
$$

è¾“å‡ºæ–¹ç¨‹ä¸ä¸‹ä¸€çŠ¶æ€æ–¹ç¨‹å¦‚ä¸Šæ‰€ç¤ºã€‚

---

#### Circuit Architecture

**Standard Controller Structure:**

```
Inputs:  b
Outputs: x
State Register: (sâ‚, sâ‚€)
Combinational Logic: determines (nâ‚, nâ‚€, x)
Clock: rising edge triggers state update
```

æ ‡å‡†æ§åˆ¶å™¨ç»“æ„åŒ…æ‹¬ï¼šè¾“å…¥ã€ç»„åˆé€»è¾‘ã€çŠ¶æ€å¯„å­˜å™¨ä¸æ—¶é’Ÿã€‚

---

#### Block Diagram (Textual Representation)

```
+-------------------------+
|        FSM Logic        |
|  +-------------------+  |
|  | Combinational F,G |  |
|  +-------------------+  |
|   â†‘           â†“         |
|  Inputs(b)  Outputs(x)  |
+-----------â”¬-------------+
            |
       +----â”´----+
       | Flip-flops |
       | (sâ‚, sâ‚€)   |
       +-------------+
            â†‘ Clock â†‘
```

è¯¥å›¾æè¿°äº†FSMæ§åˆ¶å™¨çš„æ ‡å‡†ç»“æ„ï¼šç»„åˆé€»è¾‘ + çŠ¶æ€å¯„å­˜å™¨ + æ—¶é’ŸåŒæ­¥æ›´æ–°ã€‚

---

### 10. Controller Design Process (Summary)

| Step | Description                                                       | ä¸­æ–‡è¯´æ˜                |
| :--: | :---------------------------------------------------------------- | :------------------ |
|   1  | Capture FSM behavior (draw state diagram)                         | æ•æ‰ç›®æ ‡è¡Œä¸ºï¼ˆç»˜åˆ¶çŠ¶æ€å›¾ï¼‰       |
|  2A  | Define architecture: flip-flops + combinational logic             | å®šä¹‰ä½“ç³»ç»“æ„ï¼šè§¦å‘å™¨+ç»„åˆé€»è¾‘     |
|  2B  | Encode states as binary                                           | ç”¨äºŒè¿›åˆ¶ä¸ºçŠ¶æ€ç¼–ç            |
|  2C  | Create truth table linking (inputs, state) â†’ (next state, output) | å»ºç«‹è¾“å…¥ä¸çŠ¶æ€åˆ°è¾“å‡ºä¸ä¸‹ä¸€çŠ¶æ€çš„çœŸå€¼è¡¨ |
|  2D  | Derive and simplify logic equations                               | æ¨å¯¼å¹¶åŒ–ç®€é€»è¾‘æ–¹ç¨‹           |
|  2E  | Implement with gates and flip-flops                               | ç”¨é€»è¾‘é—¨å’Œè§¦å‘å™¨å®ç°ç”µè·¯        |

---

### 11. Mealy and Moore Machines (Detailed)

#### Moore Machine

**Output depends only on the current state.**
è¾“å‡ºä»…ä¾èµ–å½“å‰çŠ¶æ€ã€‚

$$
\text{Output} = G(\text{State})
$$

**Example:** A counter displaying â€œeven/oddâ€ based only on its state.
ä¾‹å¦‚ï¼šä¸€ä¸ªåªæ ¹æ®å½“å‰è®¡æ•°å€¼æ˜¾ç¤ºâ€œå¶/å¥‡â€çš„è®¡æ•°å™¨ã€‚

**Advantages:**

* Simpler timing behavior.
* Outputs change only on clock edges.
  ä¼˜ç‚¹ï¼š
* æ—¶åºç¨³å®šï¼Œè¾“å‡ºä»…åœ¨æ—¶é’Ÿè¾¹æ²¿å˜åŒ–ã€‚

---

#### Mealy Machine

**Output depends on both current state and input.**
è¾“å‡ºä¾èµ–å½“å‰çŠ¶æ€ä¸è¾“å…¥ã€‚

$$
\text{Output} = G(\text{State}, \text{Input})
$$

**Example:** A serial data detector that reacts immediately to input.
ä¾‹å¦‚ï¼šä¸€ä¸ªåœ¨æ£€æµ‹åˆ°ç‰¹å®šè¾“å…¥åºåˆ—æ—¶ç«‹å³è¾“å‡ºä¿¡å·çš„æ£€æµ‹å™¨ã€‚

**Advantages:**

* Faster response (output can change within the same clock cycle).
  ä¼˜ç‚¹ï¼š
* å“åº”æ›´å¿«ï¼Œå¯åœ¨åŒä¸€æ—¶é’Ÿå‘¨æœŸå†…æ”¹å˜è¾“å‡ºã€‚

**Disadvantages:**

* More sensitive to glitches and timing variations.
  ç¼ºç‚¹ï¼š
* å¯¹æ—¶åºå˜åŒ–æ›´æ•æ„Ÿï¼Œæ˜“äº§ç”Ÿæ¯›åˆºã€‚

---

### 12. Example Exercise: Mealy or Moore?

**Given a 2-bit counter circuit with flip-flops and enable inputs (EN).**
ç»™å®šä¸€ä¸ªåŒ…å«è§¦å‘å™¨ä¸ä½¿èƒ½è¾“å…¥ENçš„2ä½è®¡æ•°å™¨ç”µè·¯ã€‚

**Inputs:** Clock, EN, MAX.
è¾“å…¥ä¿¡å·ï¼šæ—¶é’Ÿã€ä½¿èƒ½ã€æœ€å¤§è®¡æ•°æŒ‡ç¤ºã€‚

**Question:** Is the output logic dependent on input or state only?
é—®é¢˜ï¼šè¾“å‡ºé€»è¾‘æ˜¯å¦ä¾èµ–è¾“å…¥ï¼Ÿ

**Answer:**
If output depends on MAX or EN while changing within a state â†’ Mealy Machine.
è‹¥è¾“å‡ºåœ¨çŠ¶æ€å†…å—è¾“å…¥å½±å“è€Œå˜åŒ– â†’ Mealyæœºã€‚

If output depends solely on stored state bits â†’ Moore Machine.
è‹¥è¾“å‡ºä»…ä¾èµ–å­˜å‚¨çŠ¶æ€ä½ â†’ Mooreæœºã€‚

---

### 13. Summary

**We have introduced:**
æˆ‘ä»¬å·²ç»å­¦ä¹ äº†ï¼š

* The concept and structure of Finite State Machines (FSMs).
  æœ‰é™çŠ¶æ€æœºçš„æ¦‚å¿µä¸ç»“æ„ã€‚

* How to capture sequential behavior using state diagrams and tables.
  å¦‚ä½•é€šè¿‡çŠ¶æ€å›¾å’Œè¡¨æ ¼æ•æ‰æ—¶åºè¡Œä¸ºã€‚

* The design process: from specification â†’ state encoding â†’ circuit realization.
  è®¾è®¡æµç¨‹ï¼šä»åŠŸèƒ½æè¿°â†’çŠ¶æ€ç¼–ç â†’ç”µè·¯å®ç°ã€‚

* The distinction between Mealy and Moore machines.
  åŒºåˆ†Mealyæœºä¸Mooreæœºçš„å…³é”®å·®å¼‚ã€‚

* Practical examples including counters, turnstiles, and laser controllers.
  å®é™…æ¡ˆä¾‹åŒ…æ‹¬è®¡æ•°å™¨ã€æ—‹è½¬é—¨ä¸æ¿€å…‰æ§åˆ¶å™¨ã€‚

**FSMs are fundamental building blocks of digital systems, enabling predictable and structured sequential behavior.**
FSMæ˜¯æ•°å­—ç³»ç»Ÿçš„æ ¸å¿ƒç»“æ„ï¼Œèƒ½å®ç°å¯é¢„æµ‹ã€æœ‰åºçš„æ—¶åºæ§åˆ¶è¡Œä¸ºã€‚